SUBROUTINE ATSHOWMSG(TITLE, TEXT, FONTSIZE, TIMOUT, DELIM)
*
* ACCUTERM MESSAGE DISPLAY SUBROUTINE USING DIALOG BOX
* 
*  CALL THIS SUBROUTINE TO DISPLAY A ONE-LINE MESSAGE IN
*  A WINDOWS DIALOG BOX. PASS A TITLE, MESSAGE TEXT, FONT
*  SIZE AND TIMEOUT (IN SECONDS). IF TIMOUT = 0, THEN
*  THE MESSAGE IS DISPLAYED UNTIL THE USER CLICKS THE "OK"
*  BUTTON (OR PRESSES ENTER). IF DELIM IS NOT NULL, THE
*  MESSAGE MAY CONTAIN MULTIPLE LINES, SEPARATED BY DELIM.
*
*  NOTE: THIS SUBROUTINE BUILDS AND EXECUTES A SCRIPT WHICH
*  DISPLAYS THE MESSAGE IN A DIALOG BOX.
*
EQU ESC TO CHAR(27), STX TO CHAR(2), CR TO CHAR(13), EM TO CHAR(25)
*
IF NOT(NUM(FONTSIZE)) THEN FONTSIZE = 0
IF FONTSIZE <= 0 THEN FONTSIZE = 12
IF NOT(NUM(TIMOUT)) THEN TIMOUT = 0
*
*Build script to display message using dialog box
SCR='On Error Resume Next'
SCR=SCR:EM:'ShowMessageDialog'
SCR=SCR:EM:'End Sub'
*Globals, constants and declares go outside scope of all functions
SCR=SCR:EM:'Const WM_CLOSE = &H10'
SCR=SCR:EM:'Const WM_SETFONT = &H30'
SCR=SCR:EM:'Const LOGPIXELSX = 88'
SCR=SCR:EM:'Const LOGPIXELSY = 90'
SCR=SCR:EM:'Declare Function CreateFontA Lib "gdi32" (ByVal nHeight As Long,ByVal nWidth As Long,ByVal nEscapement As Long,ByVal nOrientation As Long,ByVal fnWeight As Long,ByVal fdwItalic As Long,ByVal fdwUnderline As Long,ByVal fdwStrikeOut As Long,ByVal fdwCharSet As Long,ByVal fdwOutputPrecision As Long,ByVal fdwClipPrecision As Long,ByVal fdwQuality As Long,ByVal fdwPitchAndFamily As Long,ByVal lpszFace As String) As Long'
SCR=SCR:EM:'Declare Function DeleteObject Lib "gdi32" (ByVal hObject As Long) As Long'
SCR=SCR:EM:'Declare Function GetDeviceCaps Lib "gdi32" (ByVal hDC As Long,ByVal nIndex As Long) As Long'
SCR=SCR:EM:'Declare Function GetDlgItem Lib "user32" (ByVal hDlg As Long,ByVal nIDDlgItem As Long) As Long'
SCR=SCR:EM:'Declare Function GetDialogBaseUnits Lib "user32" () As Long'
SCR=SCR:EM:'Declare Function GetWindowDC Lib "user32" (ByVal hWnd As Long) As Long'
SCR=SCR:EM:'Declare Function ReleaseDC Lib "user32" (ByVal hWnd As Long,ByVal hDC As Long) As Long'
SCR=SCR:EM:'Declare Function SendMessageA Lib "user32" (ByVal hWnd As Long, ByVal uMsg As Long,ByVal wParam As Long,ByVal lParam As Long) As Long'
SCR=SCR:EM:'Dim hDialog As Long'
SCR=SCR:EM:'Dim hFont As Long'
SCR=SCR:EM:'Dim Endtime As Long'
*Now build the ShowMessageDialog subroutine
SCR=SCR:EM:'Sub ShowMessageDialog'
SCR=SCR:EM:'Dim hDC As Long'
SCR=SCR:EM:'Dim FontHeight As Long'
SCR=SCR:EM:'Dim DUX As Long'
SCR=SCR:EM:'Dim DUY As Long'
SCR=SCR:EM:'Dim HorzRes As Long'
SCR=SCR:EM:'Dim VertRes As Long'
SCR=SCR:EM:'Dim TextWidth As Long'
SCR=SCR:EM:'Dim TextHeight As Long'
SCR=SCR:EM:'Dim Title As String'
SCR=SCR:EM:'Dim Message As String'
SCR=SCR:EM:'Dim Size As Long'
SCR=SCR:EM:'Dim Timeout As Long'
SCR=SCR:EM:'On Error Resume Next'
ARG=TITLE; GOSUB 100; * fixup any embedded double-quotes
SCR=SCR:EM:'Title="':ARG:'"'
IF DELIM EQ '' THEN
 * single line
 NLS=1
 ARG=TEXT; GOSUB 100; * fixup any embedded double-quotes
 SCR=SCR:EM:'Message="':ARG:'"'
END ELSE
 * multiple lines
 NLS=DCOUNT(TEXT,DELIM)
 FOR I=1 TO NLS
  ARG=FIELD(TEXT,DELIM,I); GOSUB 100
  LOOP WHILE LEN(ARG) > 250 DO
   SCR=SCR:EM:'Message = Message & "':ARG[1,250]:'"'
   ARG=ARG[251,999999]
  REPEAT
  SCR=SCR:EM:'Message = Message & "':ARG:'"'
  IF I<NLS THEN SCR=SCR:EM:'Message = Message & vbCrLf'
 NEXT I
END
SCR=SCR:EM:'Size=':FONTSIZE
SCR=SCR:EM:'Timeout=':TIMOUT
SCR=SCR:EM:'If Timeout > 0 Then Endtime = CLng(Timer) + Timeout Else Endtime = 0'
SCR=SCR:EM:'DUY = GetDialogBaseUnits()'
SCR=SCR:EM:'DUX = DUY And &h7fff&'
SCR=SCR:EM:'DUY = Int(DUY / &h10000&)'
SCR=SCR:EM:'hDC = GetWindowDC(0)'
SCR=SCR:EM:'HorzRes = GetDeviceCaps(hDC,LOGPIXELSX)'
SCR=SCR:EM:'VertRes = GetDeviceCaps(hDC,LOGPIXELSY)'
SCR=SCR:EM:'FontHeight = Size * VertRes / 72'
SCR=SCR:EM:'ReleaseDC 0,hDC'
SCR=SCR:EM:'hFont = CreateFontA(-FontHeight,0,0,0,700,0,0,0,0,0,0,0,0,"Arial")'
SCR=SCR:EM:'TextHeight = 5 + (':NLS:' * Int(FontHeight * 18 / DUY))'
SCR=SCR:EM:'TextWidth = Int(FontHeight * 36 / DUX)'
SCR=SCR:EM:'If TextWidth < 380 Then TextWidth = 380'
*Define dialog box
SCR=SCR:EM:'Begin Dialog UserDialog TextWidth+20,TextHeight+50,Title,.DialogFunc'
SCR=SCR:EM:'Text 10,10,TextWidth,TextHeight,Message,.Text1,2'
SCR=SCR:EM:'OKButton (TextWidth/2)-35,TextHeight+20,90,20'
SCR=SCR:EM:'End Dialog'
*Display the dialog box
SCR=SCR:EM:'Dim dlg As UserDialog'
SCR=SCR:EM:'Dialog dlg'
SCR=SCR:EM:'DeleteObject hFont'
*Notify host
SCR=SCR:EM:'InitSession.Activate'
SCR=SCR:EM:'InitSession.Output vbCr'
SCR=SCR:EM:'End Sub'
*Define dialog function
SCR=SCR:EM:'Private Function DialogFunc(DlgItm$, Action%, SuppVal&) As Boolean'
SCR=SCR:EM:'Select Case Action%'
*Set the font
SCR=SCR:EM:'Case 1'
SCR=SCR:EM:'hDialog=SuppVal&'
SCR=SCR:EM:'SendMessageA GetDlgItem(hDialog,DlgControlID("Text1")),WM_SETFONT,hFont,1'
SCR=SCR:EM:'Case 5'
SCR=SCR:EM:'If Endtime>0 Then'
SCR=SCR:EM:'If CLng(Timer) >= Endtime Then'
SCR=SCR:EM:'SendMessageA hDialog,WM_CLOSE,0,0'
SCR=SCR:EM:'Else'
SCR=SCR:EM:'DialogFunc = True'
SCR=SCR:EM:'Wait 1'
SCR=SCR:EM:'End If'
SCR=SCR:EM:'End If'
SCR=SCR:EM:'End Select'
SCR=SCR:EM:'End Function'
*Since host scripts get automatic End Sub, need a dummy Begin Sub
SCR=SCR:EM:'Sub Dummy'
*Execute script
PRINT ESC:STX:'P':SCR:CR:
*Retrieve the result
PROMPT ''
ECHO OFF
INPUT ANS:
ECHO ON
PROMPT '?'
RETURN
*
100 * Local subroutine to fixup embedded double-quote marks
K = 1
LOOP
 J = INDEX(ARG, '"', K)
WHILE J DO
 ARG = ARG[1, J] : ARG[J, 99999]
 K = K + 2
REPEAT
RETURN
*
END

