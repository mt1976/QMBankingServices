SUBROUTINE ATINPUTTEXT(PRMPT, TEXT, WIDTH, HEIGHT, DELIM)
*
* ACCUTERM TEXT INPUT SUBROUTINE USING SCRIPT DIALOG BOX
* 
*  CALL THIS SUBROUTINE TO INPUT TEXT USING A WINDOWS
*  DIALOG BOX. PASS A PROMPT MESSAGE, INITIAL TEXT VALUE
*  WIDTH IN CHARACTERS, HEIGHT IN LINES AND LINE DELIMITER.
*  DELIM IS NULL FOR SINGLE LINE TEXT ENTRY (HEIGHT IS
*  IGNORED IN THIS CASE). OTHERWISE, MULTIPLE LINES ARE
*  SEPARATED BY THE SPECIFIED DELIMITER. RESULT IS RETURNED
*  IN THE TEXT ARGUMENT. IF THE USER CLICKS THE CANCEL
*  BUTTON, NULL IS RETURNED.
*
*  NOTE: THIS SUBROUTINE BUILDS AND EXECUTES A SCRIPT WHICH
*  PERFORMS THE TEXT INPUT, THEN TRANSMITS THE RESULTS BACK
*  TO THE HOST.
*
EQU ESC TO CHAR(27), STX TO CHAR(2), CR TO CHAR(13), EM TO CHAR(25)
EQU BEL TO CHAR(7)
*Calculate dialog box size in "dialog units"
WD=WIDTH*8; IF WD<250 THEN WD=250
IF DELIM='' THEN ML=0 ELSE ML=1
IF ML THEN
 HT=HEIGHT*12; IF HT<100 THEN HT=100
 CY=HT+60
END ELSE
 HT=18
 CY=78
END
CX=WD+20
DX=INT((CX-120)/3)
DY=CY-25
*Build script to display/edit text using dialog box
SCR='Begin Dialog UserDialog ':CX:',':CY:',"AccuTerm",.DialogFunc'
SCR=SCR:EM:'Text 10,10,':WD:',12,"':PRMPT:'"'
SCR=SCR:EM:'TextBox 10,27,':WD:',':HT:',.Text1,':ML
SCR=SCR:EM:'OKButton ':DX:',':DY:',60,20'
SCR=SCR:EM:'CancelButton ':(2*DX)+60:',':DY:',60,20'
SCR=SCR:EM:'End Dialog'
SCR=SCR:EM:'Dim Dlg As UserDialog'
SCR=SCR:EM:'Dim Text$'
SCR=SCR:EM:'Dim i%'
SCR=SCR:EM:'Dim n%'
*Load initial text value
SCR=SCR:EM:'On Error Resume Next'
IF ML THEN
 N=DCOUNT(TEXT,DELIM)
 FOR I=1 TO N
  ARG=FIELD(TEXT,DELIM,I); GOSUB 100
  LOOP WHILE LEN(ARG) > 250 DO
   SCR=SCR:EM:'Text$ = Text$ & "':ARG[1,250]:'"'
   ARG=ARG[251,999999]
  REPEAT
  SCR=SCR:EM:'Text$ = Text$ & "':ARG:'"'
  IF I<N THEN SCR=SCR:EM:'Text$ = Text$ & vbCrLf'
 NEXT I
END ELSE
 ARG=TEXT; GOSUB 100
 SCR=SCR:EM:'Text$ = "':ARG:'"'
END
SCR=SCR:EM:'Dlg.Text1 = Text$'
*Display the dialog box
SCR=SCR:EM:'Dialog Dlg'
*Transmit results to host
SCR=SCR:EM:'InitSession.Activate'
IF ML THEN
 SCR=SCR:EM:'If Err Then'
 SCR=SCR:EM:'InitSession.Output "-1" & vbCr'
 SCR=SCR:EM:'Else'
 SCR=SCR:EM:'Text$ = Dlg.Text1'
 SCR=SCR:EM:'n=LineCount(Text$)'
 SCR=SCR:EM:'InitSession.InputMode=2'
 SCR=SCR:EM:'InitSession.Output CStr(n) & vbCr'
 SCR=SCR:EM:'For i=1 To n'
 SCR=SCR:EM:'If InitSession.WaitFor(0,5,Chr$(7)) Then'
 SCR=SCR:EM:'InitSession.Output Line(Text$,i,i) & vbCr'
 SCR=SCR:EM:'End If'
 SCR=SCR:EM:'Next i'
 SCR=SCR:EM:'InitSession.InputMode=0'
 SCR=SCR:EM:'End If'
END ELSE
 SCR=SCR:EM:'If Err = 0 Then Text$ = Dlg.Text1 Else Text$ = ""'
 SCR = SCR:EM:'InitSession.Output Text$ & vbCr'
END
*Define dialog function to unselect text upon entry
SCR = SCR:EM:'End Sub'
SCR = SCR:EM:'Private Declare Function SendDlgItemMessage& Lib "user32" (ByVal hWnd&, ByVal ID&, ByVal uMsg&, ByVal wp&, ByVal lp&)'
*Unselect the text & position cursor to beginning
SCR = SCR:EM:'Dim DlgWnd&'
SCR = SCR:EM:'Private Function DialogFunc(DlgItm$, Action%, SuppVal&) As Boolean'
SCR = SCR:EM:'Select Case Action%'
SCR = SCR:EM:'Case 1'
SCR = SCR:EM:'DlgWnd&=SuppVal&'
SCR = SCR:EM:'Case 4'
SCR = SCR:EM:'SendDlgItemMessage DlgWnd&,DlgControlID("Text1"),177,0,0'
SCR = SCR:EM:'Case 5'
SCR = SCR:EM:'DlgFocus "Text1"'
SCR = SCR:EM:'End Select'
SCR = SCR:EM:'End Function'
*Since host scripts get automatic End Sub, need a dummy Begin Sub
SCR = SCR:EM:'Sub Dummy'
*Execute script
PRINT ESC:STX:'P':SCR:CR:
*Retrieve the result
PROMPT ''
ECHO OFF
INPUT ANS:
IF ML THEN
 TEXT=''
 N=OCONV(ANS,'MCN')+0
 IF ANS>=0 THEN
  FOR I=1 TO N
   PRINT BEL:
   INPUT ANS:
   TEXT=TEXT:ANS
   IF I<N THEN TEXT=TEXT:DELIM
  NEXT I
 END
END ELSE
 TEXT=ANS
END
ECHO ON
PROMPT '?'
RETURN
*
100 * Local subroutine to fixup embedded double-quote marks
K = 1
LOOP
   J = INDEX(ARG, '"', K)
WHILE J DO
   ARG = ARG[1, J] : ARG[J, 99999]
   K = K + 2
REPEAT
RETURN
*
END
