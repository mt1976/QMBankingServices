      program ae

* This editor reproduces the UniData Alternate Editor for QM
* The code is based on LED, a line editor released into
* public domain by the Public Trustee of New Zealand.
* Written by Keith Robert Johnson.

*====================================================================
* Version information
*  3.02 - Added no-file default syntax help 6317
*         Make : or ; delimiter pin the start or end column
*         Fixed FMA by adding LOCAL to endwords
*         Add QSORT (QS) using QM !SORT subroutine
*         Add '//' search like '/' to look only at working lines
*         Add lastfind to edkeep data so it stays highlighted
*         Allow delimiter * to be interpreted as a large number
*         Added ED-style external commands
*         Checked for numbers as well as letters in Ctrl-W
*         PTERM MARK effectively ignored in page edit mode
*         Prior FORMAT ignored when quitting
*         Removed F12 as 'escp' and coded directly so UK12 works
*         + and - commands catered for in stack history cumulatively
*         Added 'W'orking and 'R'emark modifiers to 'L'ocate command 
*         Fixed where empty item looked like new one
*         Fixed colour problem with ';*' within quotes
*         and using backslash as a quote
*         Added 'E' option to restrict XEQ like SED does
*  3.01 - Fixed colour display when spanning terminal lines
*         Added Mouse Switch, ^X = XEQ, in Page Mode.
*         Changed COUNT to go to top when at bottom.
*  3.00 - Added BC functions, C columns, CM arithmetic functions,
*         DB, DBV, DBW debug commands, HOLD and YANK list commands,
*         OUT and SPOUT logic displays, UK user keys, PE tab to word,
*         PE change word case key, PE quit prompt, PE F10 menus,
*         B option for binary viewing, D option for paragraph control
*         of editor, H option for hexadecimal output in Page Mode,
*         New $ED.OPTIONS - BLEACH, INWORD, PAGE, ZOOM, MOUSE.
*         ZOOM, { and } page mode commands, mouse clicks,
*         and colour thanks to Brian Leach (BLEACH command!)
*         Changed existing MESSAGES and added 6314 6315 6316
*  2.00 - Simplified code for QM - No longer supporting R83.
*         Downcased the source to comply with QM standards.
*         Used MESSAGES 6300 to 6313 for help, prompts, etc.
*====================================================================

$ifdef qm
$define qmterm
$include err.h
      voc = @voc
$else
      open 'VOC' to voc else
          open 'MD' to voc else stop 201,'VOC'
      end
$endif
$ifdef universe
$options information
$endif
$ifdef unidata
$basictype 'U'
$endif

* INITIALISE
      prompt ''

      am = char(254); vm = char(253); sm = char(252)
      qt = '"\':"'"

      common /ae$data/ edkeep,secure,kept(9)

      equ ulet to 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
      equ llet to 'abcdefghijklmnopqrstuvwxyz'
      equ slet to '                          '
      equ digits to '1234567890'
      equ cellsize to 100
      dim memr(1)

* XCOM data - YES this editor will do $commands like AE does
      dim junk(100)
      equ this to junk(1)
      equ item to junk(2)
      equ here to junk(3)
!      EQU beg  to junk(4)
!      EQU fin  to junk(5)
      equ x$cc to junk(11)
      equ comi to junk(13)
      equ comd to junk(14)
      equ last to junk(15)
      equ comdmark to junk(19)
      equ wordmark to junk(20)
      equ fnam to junk(24)
      equ xsep to junk(25)
      mat junk = ''
      xsep = ' '
      wordmark = ' '
      comdmark = '`'

* Local data
      begn = @(0)   ; ceop = @(-3)  ; ceol = @(-4)  ; goup = @(-10)
      revb = @(-13) ; revf = @(-14) ; undb = @(-15) ; undf = @(-16)
      flab = @(-5)  ; flaf = @(-6)  ; bolb = @(-58) ; bolf = @(-59)

      editpage = @true
      heap = @false ; salt = '' ; rlen = 0
      plen = system(3)-1 ; pwin = plen-1 ; line = '' ; here = 0
      dim fr(10) ; mat fr = '' ; fr(3) = 'MCU'
      oops = '' ; oopc = '' ; ooph = ''
      oopb = '' ; oopf = '' ; oopk = ''
      join = '' ; nill = '' ; fold = ''
      macn = 0 ; macc = '' ; back = -1
      pick = '' ; lastfind = '' ; huge = 99999999
      inword = ''

* Turn off page prompt
      test = @(0,0)

* Find Match words - a LOOP can have multiple WHILE and UNTIL conditions
      fm.words = '' ; fm.findf = '' ; fm.finda = ''
      fm.words<1> = 'END'       ; fm.findf<1> = 'END'
      fm.finda<1> = 'IFýENDýOPENýOPENPATHýOPENSEQýBEGINýLOCATEýLOCALýPUBLICýTRYýCATCHýREADUýREADVUýMATREADU'
      fm.words<2> = 'LOOP'      ; fm.findf<2> = 'REPEATýUNTILýWHILE'
      fm.words<3> = 'UNTIL'     ; fm.findf<3> = fm.findf<2>
      fm.finda<3> = 'LOOPýUNTILýWHILE'
      fm.words<4> = 'WHILE'
      fm.findf<4> = fm.findf<2> ; fm.finda<4> = fm.finda<3>
      fm.words<5> = 'FOR'       ; fm.findf<5> = 'NEXT'
      fm.words<6> = 'NEXT'      ; fm.finda<6> = 'FOR'
      fm.words<7> = 'BEGIN'     ; fm.findf<7> = 'END CASEýCASE'
      fm.words<8> = 'CASE'      ; fm.findf<8> = 'CASEýEND CASE'
      fm.finda<8> = 'BEGIN CASEýCASE'
      fm.words<9> = 'LOCKED'    ; fm.findf<9> = 'END'
      fm.finda<9> = 'READUýREADVUýMATREADU'
      fm.words<10> = 'REPEAT'   ; fm.finda<10> = fm.finda<3>
      fm.words<11> = 'LOCAL'    ; fm.findf<11> = 'END'
      fm.words<11> = 'PUBLIC'   ; fm.findf<11> = 'END'
* a TRY can have multiple CATCH conditions
      fm.words<12> = 'TRY'      ; fm.findf<12> = 'ENDýCATCH'
      fm.words<13> = 'CATCH'    ; fm.findf<13> = 'ENDýCATCH'
      fm.finda<13> = 'TRYýCATCH'
* For viewing C code
      fm.words<14> = '{' ; fm.findf<14> = '}'
      fm.words<15> = '}' ; fm.finda<15> = '{'
      endwords = 'IFýLOCATEýLOCALýMATREADýMATREADUýOPENýOPENPATHýOPENSEQýREADýREADNEXTýREADUýREADVýREADVU'

* page editor stuff
      botl = system(3) - 2 ; clpg = @(-1) ; bolt = botl
      bell = @sys.bell ; span = system(2) ; pant = span ; biggest = 2*span
      bott = @(0,system(3)-1):ceol
      stub = ''

* Define key activity numbers - 27 keys defined
      equ uarr to 1,  darr to 2,  larr to 3,  rarr to 4
      equ upag to 5,  dpag to 6,  lpag to 7,  rpag to 8
      equ tpag to 9,  bpag to 10
      equ escp to 11, phlp to 12, zoom to 13
      equ delc to 14, dell to 15, delr to 16
      equ bspc to 17, carr to 18, togg to 19, writ to 20
      equ skey to 21, rkey to 22, menu to 23
      equ ftab to 24, btab to 25, wkey to 26
      equ mous to 27, xkey to 28

* Set up the keys - In QM we can use generic key mapping (YAY)
* but I also like to have default keys
      acts = '' ; keys = ''
* Arrow keys
      acts<-1> = uarr ; keys<-1> = char(205)
      acts<-1> = uarr ; keys<-1> = char(26)
      acts<-1> = darr ; keys<-1> = char(206)
      acts<-1> = darr ; keys<-1> = char(10)
      acts<-1> = larr ; keys<-1> = char(203)
      acts<-1> = larr ; keys<-1> = char(21)
      acts<-1> = rarr ; keys<-1> = char(204)
      acts<-1> = rarr ; keys<-1> = char(6)
* Page movement keys
      acts<-1> = upag ; keys<-1> = char(207)
      acts<-1> = upag ; keys<-1> = char(16)
      acts<-1> = dpag ; keys<-1> = char(208)
      acts<-1> = dpag ; keys<-1> = char(14)
      acts<-1> = lpag ; keys<-1> = char(209)
      acts<-1> = lpag ; keys<-1> = char(1)
      acts<-1> = rpag ; keys<-1> = char(210)
      acts<-1> = rpag ; keys<-1> = char(5)
      acts<-1> = tpag ; keys<-1> = char(214)
      acts<-1> = tpag ; keys<-1> = char(20)
      acts<-1> = bpag ; keys<-1> = char(215)
      acts<-1> = bpag ; keys<-1> = char(2)
* delete character, line, and delete to end of line keys
      acts<-1> = delc ; keys<-1> = char(212)
      acts<-1> = delc ; keys<-1> = char(4)
      acts<-1> = dell ; keys<-1> = char(216)
      acts<-1> = dell ; keys<-1> = char(127)
      acts<-1> = dell ; keys<-1> = char(12)
      acts<-1> = delr ; keys<-1> = char(217)
      acts<-1> = delr ; keys<-1> = char(11)
*     acts<-1> = delr ; keys<-1> = char(18) ;* for Wyse terminals
* backspace and carriage return keys
      acts<-1> = bspc ; keys<-1> = char(008)
      acts<-1> = carr ; keys<-1> = char(013)
* escape, help, Go to line, toggle insert/overwrite mode, save keys
      acts<-1> = escp ; keys<-1> = char(027) ;* Escape for abandon
      acts<-1> = escp ; keys<-1> = char(017) ;* Ctrl-Q for abandon
      acts<-1> = phlp ; keys<-1> = char(128)
      acts<-1> = zoom ; keys<-1> = char(007)
      acts<-1> = togg ; keys<-1> = char(211)
      acts<-1> = writ ; keys<-1> = char(129)
* tab keys
      acts<-1> = ftab ; keys<-1> = char(009)
      acts<-1> = btab ; keys<-1> = char(213)
* search key, reverse search key
      acts<-1> = skey ; keys<-1> = char(130) ;* F3 for search
      acts<-1> = rkey ; keys<-1> = char(131) ;* F4 for reverse search
* menu key
      acts<-1> = menu ; keys<-1> = char(137) ;* F10 for menu key
* wiggle key
      acts<-1> = wkey ; keys<-1> = char(023) ;* Ctrl-w to change case
* xeq key
      acts<-1> = xkey ; keys<-1> = char(024) ;* Ctrl-x for XEQ in page edit mode

      mouser = '' ;* Control for mouse capability

* Display details with colours similar to Brian Leach's Z editor
*-------------------------------------------------------------------------
      dim colours(9,2)
      equ hi.commenton  to colours(1,1) , hi.commentoff to colours(1,2)
      equ hi.labelon    to colours(2,1) , hi.labeloff   to colours(2,2)
      equ hi.selecton   to colours(3,1) , hi.selectoff  to colours(3,2)
      equ hi.stringon   to colours(4,1) , hi.stringoff  to colours(4,2)
      equ hi.keyon      to colours(5,1) , hi.keyoff     to colours(5,2)
      equ hi.opon       to colours(6,1) , hi.opoff      to colours(6,2)
      equ hi.funcon     to colours(7,1) , hi.funcoff    to colours(7,2)
      equ hi.diron      to colours(8,1) , hi.diroff     to colours(8,2)
      equ hi.docon      to colours(9,1) , hi.docoff     to colours(9,2)

      equ si.label     to 1
      equ si.comment   to 2
      equ si.string    to 3
      equ si.key       to 4
      equ si.operator  to 5
      equ si.function  to 6
      equ si.directive to 7
      equ si.highlight to 8
      equ si.doc       to 9

      kwords = convert('~',am,sysmsg(6315)<2>) ; del kwords<1>
      fwords = convert('~',am,sysmsg(6315)<3>) ; del fwords<1>

* Highlights
      gosub set.colours
      if not(normal) then
         hi.selecton = revb
         hi.selectoff = revf
         hi.labelon = revb
         hi.labeloff = revf
         hi.keyon = undb
         hi.keyoff = undf
         hi.funcon = undb
         hi.funcoff = undf
      end
*-------------------------------------------------------------------------

      def.mode = 'LINE'
      site = 1
      pchr = 1
      ptop = 1
      mine = ''

* The saved stuff
      pres = '' ; look = '' ; stak = ''
      wild = @false ; shew = @false
      chan = '' ; olda = '' ; cmat = '' ; mmat = ''
      caseflag = @false ; spaceflag = @true ; blockflag = @true ; brian = @false
      ukey = ''

* Save the standard defaults in the session variable if it's not set
      if assigned(edkeep) else edkeep = '0'
      if edkeep eq '0' then
         edkeep = pres:am:look:am:stak:am:wild:am:chan:am:olda:am:shew
         edkeep := am:cmat:am:mmat:am:not(caseflag):am:not(spaceflag)
         edkeep := am:not(blockflag):am:brian:am:not(pant = span)
         edkeep := am:ukey:am:lastfind
         mat kept= ''
      end

* Get the 'as-is' settings from the session variable
      pres = edkeep<1>
      look = edkeep<2>
      stak = edkeep<3>
      wild = edkeep<4> ; wild = not(not(wild))
      chan = edkeep<5>
      olda = edkeep<6>
      shew = edkeep<7> ; shew = not(not(shew))
      cmat = edkeep<8>
      mmat = edkeep<9>
      caseflag = not(edkeep<10>)
      spaceflag = not(edkeep<11>)
      blockflag = not(edkeep<12>)
      brian = edkeep<13>
      if not(edkeep<14>) then
         pant = span
         bolt = botl
      end else
         pant = int(span/2)
         bolt = int(botl/2)
      end
      ukey = edkeep<15>
      lastfind = edkeep<16>

* Get forced default flags

      readv temp from voc,'$RELEASE',3 else temp = ''
      temp = upcase(temp)
      editends = index(temp,'E',1)
      editover = index(temp,'O',1)
      editshow = index(temp,'S',1)
      editaint = index(temp,'X',1)

* Imitate ED use of external commands
* NOTE ext.data(8) is ev.depth which has no meaning to AE
      ext.prog = ''
      ext.code = ''
      ext.posn = ''
      dim ext.data(8)
      equ fnam% to ext.data(1)
      equ item% to ext.data(2)
      equ this% to ext.data(3)
      equ here% to ext.data(4)
      equ beg%  to ext.data(5)
      equ fin%  to ext.data(6)
      equ ucom% to ext.data(7)

      read temp from voc, '$ED.OPTIONS.':upcase(@logname) else
         read temp from voc, '$ED.OPTIONS' else temp = ''
      end
      if temp ne '' then
         line = upcase(trim(remove(temp, dlim)))
         if line[1,1] eq 'X' then
            term = upcase(@term.type)
            loop
               line = upcase(trim(remove(temp, dlim)))
               begin case
                  case line[1,7] eq 'BELL ON'
                     bell = @sys.bell
                  case line[1,8] eq 'BELL OFF'
                     bell = ''
                  case line[1,9] eq 'BLEACH ON'
                     brian = @false
                  case line[1,10] eq 'BLEACH OFF'
                     brian = @true
                  case line[1,8] eq 'BLOCK ON'
                     blockflag = @true
                  case line[1,9] eq 'BLOCK OFF'
                     blockflag = @false
                  case line[1,7] eq 'CASE ON'
                     caseflag = @true
                  case line[1,8] eq 'CASE OFF'
                     caseflag = @false
                  case line[1,8] eq 'SPACE ON'
                     spaceflag = @true
                  case line[1,9] eq 'SPACE OFF'
                     spaceflag = @false
                  case line[1,7] eq 'SHOW ON'
                     shew = @true
                  case line[1,8] eq 'SHOW OFF'
                     shew = @false
                  case line[1,6] eq 'ZOOM H'
                     pant = int(span/2)
                     bolt = int(botl/2)
                  case line[1,6] eq 'ZOOM F'
                     pant = span
                     bolt = botl
                  case line[1,4] eq 'PAGE'
                     def.mode = 'PAGE'
                  case field(line,' ',1) eq 'INWORD'
                     inword = field(line,' ',2)
                  case field(line,' ',1) eq 'MOUSE'
                     word = field(line,' ',2,2)
                     begin case
                        case word eq term:' ASCII'       ;* kmous=^Bp
                           mouse.on = char(27):char(2):'1'
                           mouse.off = char(27):char(2):'0'
                           acts<-1> = mous
                           keys<-1> = char(200)
                           mouser = 'ASCII'
                        case word eq term:' ANSI'        ;* kmous=\E[101~  !
                           mouse.on = char(27):char(2):'1'
                           mouse.off = char(27):char(2):'0'
                           acts<-1> = mous
                           keys<-1> = char(200)
                           mouser = 'ANSI'
                        case word eq term:' HOSTACCESS'  ;*kmous=^BMS\r
                           mouse.on = char(27):'[=27;1h' ;* 1=left 2=right 4=centre so 7=all 3=left+right
                           mouse.off = char(27):'[=27;0h'
                           acts<-1> = mous
                           keys<-1> = char(200)
                           mouser = 'HOSTACCESS'
                        case word eq term:' XTERM'       ;* kmous=\E[M
                           mouse.on = char(27):'[?1000h' ;* turns on all and get.mouse test for left or right
                           mouse.off = char(27):'[?1000l'
                           acts<-1> = mous
                           keys<-1> = char(200)
                           mouser = 'XTERM'
                        case word eq term:' XTERM9'      ;* kmous=\E[M
                           mouse.on = char(27):'[?9h'    ;* turns on all and get.mouse test for left or right
                           mouse.off = char(27):'[?9l'
                           acts<-1> = mous
                           keys<-1> = char(200)
                           mouser = 'XTERM'
$ifdef qmterm
                        case word eq term:' QMTERM'
                           mouse.on = char(27):'[1M'
                           mouse.off = char(27):'[0M'
                           acts<-1> = mous
                           keys<-1> = char(200)
                           mouser = 'QMTERM'
$endif
                     end case

$ifdef qm
* Getting External Command
                  case field(line,' ',1) eq 'EXTERNAL' and dcount(line,' ') ge 3
                     prog = field(line,' ',2)
                     locate prog in ext.prog<1> setting posn else ext.prog<posn> = prog
                     rest = field(line,' ',3,*)
                     loop
                        bit = rest[1,1]
                        if index(qt,bit,1) then
                           code = field(rest,bit,2)
                           rest = field(rest,bit,3,*)
                        end else
                           code = field(rest,',',1)
                           rest = field(rest,',',2,*)
                        end
                        ext.code<1,-1> = code
                        ext.posn<-1> = posn
                        rest = trim(rest)
                        if rest[1,1] eq ',' then rest = trim(rest[2,*])
                     while rest ne '' repeat
$endif
               end case
            while dlim repeat
         end
      end

      if assigned(secure) else secure = '0'

      prepprog = '' ; prepflag = @false
      postprog = '' ; postflag = @false

*********** UniData AE-style security start
$ifdef unidata
      prepprog = getenv('PREPROG_AE_UDT')
$endif
$ifdef universe
      execute 'ENV' capturing temp
      xxno = dcount(temp,am)
      for xx = 1 to xxno
         line = temp<xx>
         if field(line,'=',1) eq 'PREPROG_AE_UDT' then
            prepprog = field(line,'=',2)
            xxno = xx
         end
      next xx
$endif
$ifdef qm
* QM doesn't allow underscores in environmental variables, so
* this is the closest I can get to AE environmental variable name.

      call !atvar(prepprog,'@PREPROG.AE.UDT')
$endif

* These next two tests are from the AE security documentation
* They may not be required, but you can set them up if you want
*    if prepprog[1,3] eq 'AE_' then prepprog = ''
*    if prepprog[len(prepprog)-2,3] ne '_AE' then prepprog = ''
      if prepprog ne '' then prepflag = @true

* The following security definitions mirror those of I_AE_SECURITY
* in UniData.  I have only copied the functionality for SEC.SET
* being "NONE" (that is, this user cannot edit) and the general
* disabling of LOAD via the SEC.LOAD.FLG at first call to @PREPPROG;
* and inhibiting of file updates via subsequent @PREPPROG calls.
      dim security(40)
      equ sec.set to security(1) ;* set by preprog on very first call
* These fields are set in preprog
      equ sec.read.flg       to security(2)  ;* read ok or not
      equ sec.write.flg      to security(3)  ;* write ok or not
      equ sec.delete.flg     to security(4)  ;* delete ok or not
      equ sec.unload.flg     to security(5)  ;* unload ok or not
      equ sec.load.flg       to security(6)  ;* load ok or not
      equ sec.xeq.flg        to security(7)  ;* xeq ok or not
      equ sec.xcom.flg       to security(8)  ;* xcoms ok or not
* the following 5 fields pass information to preprog & postprog,
           equ sec.fn             to security(9)  ;* file name
      equ sec.id             to security(10) ;* record id
      equ sec.dir.flg        to security(11) ;* 1 if file is a directory
      equ sec.newfile.flg    to security(12) ;* 1 if new file name
      equ sec.active.sel.flg to security(13) ;* 1 if select list is active
* this is how to make AE stop and return to calling program or ecl
      equ sec.stop.flg       to security(14) ;* set to 1 to make ae stop
* for secondary calls to preprog; the first 3 cannot be changed
      equ sec.call2.type     to security(15) ;* 1 load, 2 unload
      equ sec.fn2            to security(16) ;* second file for load/unload
      equ sec.id2            to security(17) ;* second id   for load/unload
      equ sec.ok2.flg        to security(18) ;* if 1, ok to load/unload
* 19-22 are used by postprog, which I have not implemented
      equ sec.dict.flg       to security(23) ;* 1 if fn is dict ...
      equ sec.dict2.flg      to security(24) ;* 1 if fn2 is dict ...
* field 25 is specific to UNIDATA AE, this and all other fields unused
* WARNING: preprog programs should not use the STOP or ABORT statements
*          they should use the SEC.STOP.FLG to end nicely.
*********** UniData AE-style security end

* QM has it's own source control system depending on a callable program
* named SOURCE.CONTROL existing.  It has the following fields
*
* DICT.FLAG     - 'DICT' if a dictionary, otherwise ''
* FILE.NAME     - name of file to be written
* RECORD.NAME   - name of record to be written
* RECORD.DATA   - the record to write
* CALLER        - calling program identifier, I have used '3'
* WRITE.ALLOWED - 1 on call, returns 1 if write allowed and 0 otherwise
* UPDATED       - 0 on call, returns 1 if RECORD.DATA is changed

      source.control = @false
$ifdef qm
      if catalogued('SOURCE.CONTROL') then source.control = @true
$else
* We can implement QM-style security if we want
      if prepprog eq 'SOURCE.CONTROL' then source.control = @true
$endif
      if source.control then prepflag = @false ; prepprog = ''

      name = @logname
      levl = @level
      path = @path
      term = @tty
      whom = @userno
      acct = @who

* This is to display unprintable characters safely
      badc = char(255)
      for xx = 0 to 31    ; badc := char(xx) ; next xx
      for xx = 127 to 250 ; badc := char(xx) ; next xx
      gudc = str('~',len(badc))

      pchars = ', []{}()<>=+-/*:#!'        ; pchart = str(@fm,len(pchars))
      xchars = pchars:".;'\@$":'"':badc
      xchars = convert(inword,'',xchars) ; xchart = str(' ',len(xchars))

* Some terminals do not distinguish between these
      badc := char(251):char(252):char(253); gudc := '[\]'

* The yes/no can be language independant!
      yes = sysmsg(2057) ; yes = upcase(trim(yes))[1,1] ;*Yes
      no = sysmsg(2058) ; no = upcase(trim(no))[1,1]    ;*No
      ny = '(':no:'/':yes:') >'

* Want to see these thing in a single page
      presnumb = system(3)-2
      if presnumb gt 20 then presnumb = 20
      looknumb = presnumb; channumb = presnumb

* Want this to be no more than five pages
      staknumb = (presnumb+1)*5+1

* Parse the command line - long way in before work starts, eh?
* Anything in brackets is an option. The only ones used are
* D - Data commands             V - View only
* "verb" is how this was called so it should work to call again
      verb = ''

$ifdef qm
$include parser.h
      call !parser(parser$reset, 0, @sentence, 0)
      opts = @false
      options = ''
      sentence = ''
      loop
         call !parser(parser$get.token, type, param, keyword)
      until type eq parser$end do
         begin case
            case type eq 4 ; opts = @true
            case type eq 5 ; opts = @false
            case opts      ; options := param
            case 1         ; sentence<-1> = param
         end case
      repeat
$else
      rest = @sentence
      keepquot = @false
      gosub parse.rest
      sentence = bite
      temp = dcount(sentence,am)
      options = sentence<temp>
      if options[1,1] eq '(' then
         options = field(field(options,'(',2),')',1)
         sentence = delete(bite,temp,0,0)
      end else options = ''
$endif

* Check for Data command edit option to allow paragraph control
      if index(upcase(@option:options),'D',1) then
         mode = 'LINE'
         editpage = @false
         begn = char(13) ; goup = ''
      end

      test = upcase(sentence<1>)
      if test eq 'RUN' or test eq 'DEBUG' or test eq 'RAID' then
         verb = sentence<1>:' ':sentence<2>:' '
         sentence = delete(sentence,1,0,0)
         sentence = delete(sentence,1,0,0)
      end
      verb = verb:sentence<1>
      sentence = delete(sentence,1,0,0)

* Check if a viewing verb or option has been used
* If so, we can turn off both security systems (I hope I'm right!)
* The security flags are set safe, and each command is tested
* individually, so I think it's pretty safe.
* FORMAT is still allowed, but no other change command.

      viewflag = @false ; view = sysmsg(6306)<17> ;* edit
      if index(upcase(@option:options),'V',1) then viewflag = @true
      if viewflag then
         view = sysmsg(6306)<18> ;*view
         source.control = @false
         prepflag = @false
      end
      loadflag  = index(upcase(@option:options),'E',1)

* Check if we want to see characters as hexadecimal in page mode
      if index(upcase(@option:options),'H',1)
         then dtx = @true
         else dtx = @false

* HELP location
      help.def = '3.02'
      help = ''
      pagehelp = ''

      fnam = sentence<1>
      sentence = delete(sentence,1,0,0)
      if upcase(fnam) eq 'DICT' then
         fnam = 'DICT ':sentence<1>
         sentence = delete(sentence,1,0,0)
      end
      idlist = sentence

      if idlist eq '' and loadflag then stop

      if system(11) and idlist ne '' then
         display sysmsg(6304)<2> ;*A select list was active, but specific ids were entered.
         display sysmsg(6304)<3> ;*Select list will be ignored.
         crt str('-',len(sysmsg(6304)<3>)) ;* Select list will be ignored
         clearselect
      end

      open 'AE_COMS' to acom else
         execute 'CREATE.FILE AE_COMS DYNAMIC'
         open 'AE_COMS' to acom else stop sysmsg(1427,'AE_COMS') ;*Cannot open %1
         test = @(0,0)
      end

* Get file
      loop
         got.file = @false
         if fnam eq '' then
            if loadflag then stop
            stub = sysmsg(6501) ;*File Name?
            gosub get.rope; fnam = rope; crt
         end
         if fnam eq '' then go ae.help
         dprt = field(fnam,' ',1)
         fprt = field(fnam,' ',2)
         if fprt eq '' then fprt = dprt ; dprt = ''
         open dprt, fprt to file then
            got.file = @true
         end else
            open upcase(dprt),upcase(fprt) to file then
               got.file = @true
            end else
               display sysmsg(1427,'"':fnam:'"') ;*Cannot open %1
               fnam = ''
            end
         end
      until got.file do
      repeat

$ifdef qm
* Check for collection, read-only
      if fileinfo(file,1035) then stop sysmsg(8540)
      if fileinfo(file,1001) then display sysmsg(6500,fnam)
* See if binary option is set so char(10)s stay
      if index(upcase(@option:options),'B',1)
         then binary = @true
         else binary = @false
      if binary then mark.mapping file, off
$endif

* If there is no preference, make a guess based on the file type
      if unassigned(brian) then
         if fileinfo(file,3) eq '4'
            then brian = @true
            else brian = @false
      end

      if options ne '' then options = ' (':options:')'

* Get the record
      if idlist eq '*' then
         if loadflag then stop
         idlist = ''
         execute 'SELECT ':dprt:' ':fprt
         test = @(0,0)
      end
      if system(11) then
         eof = @false
         loop
            readnext id else eof = @true
         until eof do
            idlist<-1> = id
         repeat
      end

      hold = ''
      killsign = @false
      if idlist eq '' then
         if loadflag then stop
         stub = sysmsg(6503) ;*Record Name?
         gosub get.rope; rest = rope ; crt
         keepquot = @false
         gosub parse.rest
         idlist = bite
         bite = '' ; rest = ''
      end
      idcnt = dcount(idlist,am)
      for id = 1 to idcnt until killsign
         item = idlist<id>
         gosub edit.item
      next id

* Check if a list is to be passed out
      if hold ne '' then
         hold = trim(hold,am,'R')
         temp = dcount(hold,am)
         display sysmsg(6310,temp)<43> ;* Holding %1
         select hold
      end

      edkeep = pres:am:look:am:stak:am:wild:am:chan:am:olda:am:shew
      edkeep := am:cmat:am:mmat:am:not(caseflag):am:not(spaceflag)
      edkeep := am:not(blockflag):am:brian:am:not(pant = span)
      edkeep := am:ukey:am:lastfind
      stop


* SUBROUTINES
* ***********
edit.item:
      stopsign = @false
      here = 0 ; dnum = 0
      beg = 0 ; fin = 0 ; krj = ''
      crt
      if idcnt gt 1 then crt '<':id:'/':idcnt:'> ':

      if prepflag then
         if secure eq '0' then
            mat security = ''
            sec.set = ''
            call @prepprog(mat security)
            if sec.set eq 'NONE' then stop
            if sec.stop.flg then stop
            secure = sec.set
         end
         mat security = ''
         sec.set = secure
         if sec.set then
            sec.fn = fprt
            sec.id = item
            sec.dir.flg = fileinfo(file,3) = '4'
            sec.newfile.flg = @false
            sec.active.sel.flg = @false
            sec.dict.flg = (dprt = 'DICT')
            call @prepprog(mat security)
            if sec.stop.flg then stop
            if not(sec.read.flg) then return
         end
      end else
         sec.stop.flg = @false
         sec.read.flg = @true
         sec.write.flg = @true
         sec.delete.flg = @true
         sec.xcom.flg = @true
         sec.unload.flg = @true
         sec.load.flg = @true
         if index(upcase(@option:options),'X',1)
            then sec.xeq.flg = @false
            else sec.xeq.flg = @true
         sec.ok2.flg = @true
* Apply the viewing flag
         if viewflag then
            display sysmsg(6304)<4> ;*VIEW ONLY - NO UPDATES ALLOWED
            sec.write.flg = @false
            sec.delete.flg = @false
            sec.xcom.flg = @false
            sec.unload.flg = @false
            sec.load.flg = @false
            sec.ok2.flg = @false
         end
         if loadflag then
            sec.xeq.flg = @false
            sec.unload.flg = @false
         end
      end

      if viewflag then
         read this from file, item
            then exist = @true
            else exist = @false ; this = ''
         lock = @false
      end else
         readu this from file, item locked goto locked.record then
            exist = @true
            lock = @true
carry.on:
         end else
            exist = @false
            lock = @true
            this = ''
         end
      end

* If we are not on a windows system, we may have to remove carriage returns
* to allow a UNIX system to edit Windows source code
      if not(system(91)) and not(binary) then
         convert char(13) to '' in this
      end

      gosub parse.record
      if not(exist)
         then display sysmsg(6308,item,fnam)<3> ;*Top of new "%1" in "%2".
         else display sysmsg(6308,item,fnam,last,len(this))<2> ;*Top of "%1" in "%2", %3 lines, %4 characters.
      orig = this
      that = this
      gosub get.lfmt

* Get the default mode
      mode = def.mode
      if mode eq 'PAGE' then
         that = this ; site = here
         if this eq '' then this = am
         if here lt 1 then here = 1
         ptop = here ; lnum = 0 ; cell = 1
         line = this<1>
         mode = 'PAGE':am:'View'
         if sec.write.flg then mode<2> = 'Ins'
         pchr = 1
         chng = '' ; show = ''
         gosub display.page
         gosub get.line
         mine = line
      end

* Edit the record
      loop
         if mode<1> eq 'PAGE' then
            pcol = pchr-ppos
            prow = here+1-ptop
            if mode<2> eq 'Ins'
               then crt @(57,0):ceol:revb:mode<2>:revf:fmt(here,'R#6'):
               else crt @(57,0):ceol:mode<2>:fmt(here,'R#6'):
            crt ',':fmt(pchr,'L#6'):
            bite = mine[pchr,1]
            if bite ne '' then
               if dtx
                  then crt ' (':dtx(seq(bite)):')':
                  else crt ' (':seq(bite):')':
            end
            crt @(pcol,prow):
            gosub get.page.comd
            if mode eq 'LINE' then
               display bott:sysmsg(6304)<5>: ;*Line Editor Mode
               if that ne this then
                  display sysmsg(6304)<6>: ;* - CHANGES HAVE BEEN MADE
                  oops = that
                  if oopc[1,3] eq 'pe|'
                     then oopc = upcase(oopc)
                     else oopc = 'PE'
                  ooph = site ; oopb = beg ; oopf = fin ; oopk = krj
               end
               crt
               that = ''
               gosub display.line
            end
         end

         if mode<1> eq 'LINE' then
* Get the command
            if x$cc ne '' then
               comi = x$cc<1>
               x$cc = delete(x$cc,1,0,0)
            end else
               if mode<1> eq 'PAGE' then continue
               if salt ne '' then
                  comi = salt<1,1,1>; del salt<1,1,1>
               end else
                  stub = prmt:': '; heap = @true
                  gosub get.rope; comi = rope; heap = @false
               end
               if macn then macc<1,1,-1> = comi
            end
$ifdef qm
* EXECUTE commands are checked first
            if sec.xcom.flg and comi ne '' and upcase(comi) matches ext.code then
               gosub external.command
               stak = insert(stak,1,1,0,comi)
               stak = delete(stak,1,staknumb,0)
               continue
            end
$endif
            gosub parse.command
            if not(numb eq '' or numb matches '1N0N') then
               crt ; gosub bad.command
               continue
            end
            if comd eq '' then
               gosub null.command
               if comd eq '' then continue
            end
* Save command to list
            if comi ne '' and comi ne stak<1,1> and comd ne 'D' then
* To stop F3,F4 searches filling command stack
               if (comd eq 'L' or comd eq 'LA') and comi eq stak<1,2> then
                  stak = insert(stak,1,1,0,comi)
                  stak = delete(stak,1,3,0)
               end else
                  stak = insert(stak,1,1,0,comi)
                  stak = delete(stak,1,staknumb,0)
               end
            end
* Apply the command
            if comd ne 'R' and comd ne 'D' then crt
            if comd matches '1N0N' then
               here = comd
               if here gt last then here = last
               gosub display.line
               continue
            end
            loop
               redo = @false
               first = comd[1,1]
               posn = index('ABCDEFGHIJKLMNOPQRSTUVWXYZ',first,1)
               on posn gosub a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z
            while redo do repeat
            if stopsign then release file, item ; lock = @false ; return
         end
      repeat
      return

parse.command:
      comi = trimf(comi)
      dlim = oconv(oconv(comi,'MC/A'),'MC/N')[1,1]
      if dlim eq '' then
         rest = ''
         comd = upcase(comi)
      end else
         posn = index(comi,dlim,1)
         rest = comi[posn+1,huge]
         comd = upcase(comi[1,posn-1])
      end
      temp = oconv(comd,'MCN')[1,1]
      if temp ne '' then
         temp = index(comd,temp,1)
         numb = comd[temp,huge]
         comd = comd[1,temp-1]
      end else
         if dlim eq '*' and (rest eq '' or oconv(oconv(rest[1,1],'MC/A'),'MC/N') ne '') then
            dlim = rest[1,1]
            rest = rest[2,*]
            numb = huge
         end else numb = ''
      end
      return

parse.line:
      if line eq comdmark then line = ''
      xx = 1
      loop
         temp = index(line,'^',xx)
      while temp do
         bite = line[temp,5]
         if bite matches '"^^"3N' then
            line = line[1,temp-1]:line[temp+1,len(line)]
            xx += 1
         end else
            bite = bite[1,4]
            if bite matches '"^"3N' then
               line = line[1,temp-1]:char(bite[2,3]):line[temp+4,len(line)]
            end else xx += 1
         end
      repeat
      return

a:    begin case
         case comd eq 'A'                 ; * append
            if viewflag then gosub viewonly ; return
            if rest eq '' then rest = olda<1,1>
            if rest eq '' then
               display sysmsg(6304)<7> ;*No previous append command to repeat
               gosub bad.comd ; return
            end
            olda = rest:vm:dlim
            line = rest ; gosub parse.line ; rest = line
            chng = 0 ; save = here
            dnum = 1
            gosub set.bounds
            for here = dawn to dusk
               gosub get.line
               line = line:rest
               if not(chng) then gosub savethis
               memr(cell)<lnum> = line
               chng += 1
               if shew or dnum lt plen then gosub display.line
            next here
            here = dusk
            if chng then
               gosub reset.record
               display sysmsg(6310,chng,here)<22> ;*%1 lines changed - now at %2
            end
         case 1 ; gosub bad.command
      end case
      return

b:    begin case
         case comd eq 'B' and dlim eq ''   ; * bottom
            here = last ; gosub display.line
         case index('\B\BD\BK\BR\BS\','\':comd:'\',1)   ; * break line
            if viewflag then gosub viewonly ; return
            if rest eq '' then
               display sysmsg(6304)<8> ;*The second field is empty.
               gosub bad.comd ; return
            end
            chng = 0 ; save = here ; show = ''
            gosub set.bounds
            for here = dusk to dawn step back
               gosub get.line
               if caseflag
                  then posn = index(line,rest,1)
                  else posn = index(upcase(line),upcase(rest),1)
               if posn then
                  left = line[1,posn-1]
                  best = line[posn,len(rest)]
                  temp = line[posn+len(rest),len(line)]
                  if temp ne '' or comd eq 'BS' then
                     begin case
                        case comd eq 'BD' ; line = left:best
                        case comd eq 'BK' ; line = temp
                        case comd eq 'BR' ; line = temp:left:best
                        case comd eq 'BS' ; line = temp:best:left
                        case 1 ; line = left:best
                     end case
                     memr(cell)<lnum> = line
                     show = insert(show,1,0,0,here)
                     numb += 1
                     chng += 1
                     if comd eq 'B' then
                        dusk += 1
                        last += 1
                        lnum += 1
                        line = temp
                        gosub insert.line
                     end
                  end
               end
            next here
            if chng then
               gosub savethis
               gosub reset.record
               zzno = dcount(show,am)
               savl = 0 ; dnum = 1
               for zz = 1 to zzno
                  here = show<zz> + savl
                  if shew or dnum lt plen then gosub display.line
                  if comd eq 'B' and zzno gt 1 then
                     here += 1
                     savl += 1
                     if shew or dnum lt plen then gosub display.line
                  end
               next zz
               show = ''
            end
            if comd eq 'B'
               then here = dusk + numb - 2
               else here = dusk
            if here gt last then here = last
            if chng then
               display sysmsg(6310,numb,here)<2> ;*Split %1 records.  Now at line %2
            end
            gosub get.line
         case index('\BC\BCD\BCK\BCR\BCS\','\':comd:'\',1)   ; * Break @ Column
            if viewflag then gosub viewonly ; return
            posn = trim(field(rest,dlim,1))
            if not(posn matches '1n0n') then
               display sysmsg(6310)<42> ;*No column position given
               gosub bad.comd ; return
            end
            chng = 0 ; save = here ; show = ''
            gosub set.bounds
            for here = dusk to dawn step back
               gosub get.line
               if len(line) gt posn then
                  left = line[1,posn-1]
                  best = line[posn,1]
                  temp = line[posn+1,len(line)]
                  if temp ne '' or comd eq 'BCS' then
                     begin case
                        case comd eq 'BCD' ; line = left:best
                        case comd eq 'BCK' ; line = temp
                        case comd eq 'BCR' ; line = temp:left:best
                        case comd eq 'BCS' ; line = temp:best:left
                        case 1 ; line = left:best
                     end case
                     memr(cell)<lnum> = line
                     show = insert(show,1,0,0,here)
                     numb += 1
                     chng += 1
                     if comd eq 'BC' then
                        dusk += 1
                        last += 1
                        lnum += 1
                        line = temp
                        gosub insert.line
                     end
                  end
               end
            next here
            if chng then
               gosub savethis
               gosub reset.record
               zzno = dcount(show,am)
               savl = 0 ; dnum = 1
               for zz = 1 to zzno
                  here = show<zz> + savl
                  if shew or dnum lt plen then gosub display.line
                  if comd eq 'BC' and zzno gt 1 then
                     here += 1
                     savl += 1
                     if shew or dnum lt plen then gosub display.line
                  end
               next zz
               show = ''
            end
            if comd eq 'BC'
               then here = dusk + numb - 2
               else here = dusk
            if here gt last then here = last
            if chng then
               display sysmsg(6310,numb,here)<2> ;*Split %1 records.  Now at line %2
            end
            gosub get.line
         case comd eq 'BELL'               ; * change BELL output
            rest = trim(upcase(rest))
            begin case
               case rest eq 'ON'  ; bell = char(7)
               case rest eq 'OFF' ; bell = ''
               case bell eq ''    ; bell = char(7)
               case 1             ; bell = ''
            end case
            if bell eq ''
               then display 'bell off'
               else display 'bell on'
         case comd eq 'BLEACH'           ; * change colour flag
            rest = trim(upcase(rest))
            begin case
               case rest eq 'ON' ; brian = @false
               case rest eq 'OFF' ; brian = @true
               case 1 ; brian = not(brian)
            end case
            if brian
               then display sysmsg(6306)<30> ;*Code colouring is ON
               else display sysmsg(6306)<31> ;*Code colouring is OFF
         case comd eq 'BLOCK'               ; * change BLOCK flag
            rest = trim(upcase(rest))
            begin case
               case rest eq 'ON' ; blockflag = @true
               case rest eq 'OFF' ; blockflag = @false
               case 1 ; blockflag = not(blockflag)
            end case
            if blockflag
               then display sysmsg(6552) ;*Verification of block actions enabled
               else display sysmsg(6553) ;*Verification of block actions disabled
         case 1 ; gosub bad.command
      end case
      return

c:    begin case
         case comd eq 'C'                 ; * change
            if viewflag then gosub viewonly ; return
            if numb eq '' and dlim eq '' then
               comd = 'RA'
               comi = 'RA1'
               numb = 1
            end
            gosub change.command
         case comd eq 'CAT' ; comd = 'J' ; redo = @true
         case comd eq 'CASE'               ; * change casing flag for 'L'
            rest = trim(upcase(rest))
            begin case
               case rest eq 'ON' ; caseflag = @true
               case rest eq 'OFF' ; caseflag = @false
               case 1 ; caseflag = not(caseflag)
            end case
            if caseflag
               then display sysmsg(6541) ;*Searches are case-sensitive
               else display sysmsg(6542) ;*Searches are not case-sensitive
         case comd eq 'CD'        ; * command delimiter display (change)
            if dlim eq '' then
               display sysmsg(6304)<9>: ;*Command delimiter is
            end else
               temp = '`,;#$%&~|[]{}/"':"'"
               if index(temp,dlim,1) then
                  comdmark = dlim
                  display sysmsg(6304)<9>: ;*Command delimiter is
               end else
                  display sysmsg(6304,dlim)<40> ;*%1 is not a valid command delimiter.
                  display sysmsg(6304,temp)<41> ;*Characters available for delimiters: %1
                  display sysmsg(6304)<10> ;*Characters reserved for other uses: \.*!?-+=^@<>_:
                  display sysmsg(6304)<9>: ;*Command delimiter is
               end
            end
            if comdmark eq '"'
               then crt "'":comdmark:"'"
               else crt '"':comdmark:'"'
         case comd eq 'CLEAR'             ; * Clear the kept buffer
            gosub get.buffer
            if bnum eq '' then bnum = 1
            if not(bnum) then
               some = @false
               for xx = 1 to 9
                  if kept(xx) ne '' then some = @true
               next xx
               if some
                  then display sysmsg(6312,'')<20> ;*KEPT buffer cleared
                  else display sysmsg(6312,'')<23> ;*Nothing in KEPT buffer
               mat kept = ''
               return
            end
            if kept(bnum) eq ''
               then display sysmsg(6312,bnum)<23> ;*Nothing in KEPT buffer
               else display sysmsg(6312,bnum)<20> ;*KEPT buffer cleared
            kept(bnum) = ''
         case comd eq 'COPY'              ; * copy to kept buffer
            gosub get.buffer
            if bnum lt 1 then bnum = 1
            if rest eq '' then
               if not(beg) and not(fin) then
                  display sysmsg(6312)<2> ;*Command requests a block operation, but no block is defined.
                  gosub bad.comd ; return
               end
               rest = beg
               numb = fin-beg+1
            end else
               numb = ''
               gosub parse.nums
            end
            if not(rest matches '1N0N') or not(numb matches '1N0N') then
               display sysmsg(6305)<10> ;* Format of COPY command is
               gosub bad.comd ; return
            end
            if numb lt 1 then
               display sysmsg(6309)<3> ;*Nothing done - no lines selected.
               comi = ''; return
            end
            if numb gt last then
               display sysmsg(6309)<2> ;*Nothing done - record does not have that many lines.
               comi = '' ; return
            end
            kept(bnum) = field(this,am,rest,numb)
            numb = dcount(kept(bnum),am)
            if numb then
               display sysmsg(6312,numb,bnum,rest)<21> ;*%1 lines copied to KEPT buffer starting at line %2
               if comd eq upcase(comi) then display sysmsg(6312)<29> ;*Enter PASTE now if you meant to do an ED-style COPY
            end
         case comd eq 'CM'                ; * changematch command
            if viewflag then gosub viewonly ; return
            if rest eq '' then
               if cmat eq '' then
                  display sysmsg(6304)<11> ;*No previous ChangeMatch command to repeat.
                  comi = ''
                  return
               end else
                  dlim = cmat<1,1>
                  rest = cmat<1,2>
                  numb = cmat<1,3>
               end
            end
            gosub changematch.command
         case comd eq 'COL'               ; * column display
            temp = ''
            for xx = 1 to 9
               temp = temp:space(9):xx
            next xx
            if lfmt
               then crt begn:space(llen+2):temp[1,span-llen-3]
               else crt begn:temp[1,span-1]
            temp = str(digits,10)
            if lfmt
               then crt begn:space(llen+2):temp[1,span-llen-3]
               else crt begn:temp[1,span-1]
            temp = ''
            if here and (numb ne '' or dlim ne '') then gosub display.line
         case comd eq 'COUNT'             ; * show the count of a string
            line = rest ; gosub parse.line ; rest = line
            if rest eq '' then
               display sysmsg(6304)<12> ;*No string given to count
               gosub bad.comd ; return
            end
            if numb eq '' then numb = last
            if here ge last then here = 1
            gosub set.bounds
            if not(caseflag) then rest = upcase(rest)
            temp = 0
            for here = dawn to dusk
               gosub get.line
               if caseflag
                  then temp = temp + count(line,rest)
                  else temp = temp + count(upcase(line),rest)
            next here
            here = dusk
            display sysmsg(6308,temp)<4> ;*%1 occurances of string.
         case comd eq 'CRT'           ; * insert crt line for programmer
            if viewflag then gosub viewonly ; return
            if rest eq '' then
               display sysmsg(6304)<13> ;*You have not said what to put on CRT line!
               comi = ''
               return
            end
            gosub savethat
            here += 1 ; last += 1 ; lnum += 1
            if dlim ne '"' and dlim ne '\' then dlim = "'"
            line = 'CRT ':dlim:rest:' = ':dlim:':':rest
            gosub insert.line
            gosub reset.record
            gosub display.line
         case comd eq 'CUT'               ;* Move lines to kept buffer
            if viewflag then gosub viewonly ; return
            gosub get.buffer
            if bnum lt 1 then bnum = 1
            if rest eq '' then
               if not(beg) and not(fin) then
                  display sysmsg(6312)<2> ;*Command requests a block operation, but no block is defined.
                  gosub bad.comd ; return
               end
               rest = beg
               numb = fin-beg+1
            end else
               numb = ''
               gosub parse.nums
            end
            if not(rest matches '1N0N') or not(numb matches '1N0N') then
               display sysmsg(6305)<2> ;*Format of CUT command is:
               gosub bad.comd ; return
            end
            if numb gt last then
               display sysmsg(6309)<2> ;*Nothing done - record does not have that many lines.
               comi = '' ; return
            end
            kept(1) = field(this,am,rest,numb)
            numb = dcount(kept(1),am)
            dawn = rest
            dusk = rest+numb-1
            gosub delete.lines
            if numb then display sysmsg(6312,numb,'(1)',rest)<22> ;*%1 lines moved to KEPT buffer starting at line %2
         case 1 ; gosub bad.command
      end case
      return

d:    begin case
         case comd eq 'D'                 ; * display current line
            if here gt last then here = last
            gosub display.line
         case index('\DB\DBV\DBW\','\':comd:'\',1)   ; * Debug
            if viewflag then gosub viewonly ; return
            if comd eq 'DB' then
               test = upcase(field(trim(rest),' ',1))
               if test eq '' then test = numb
               if test eq '' then test = 1
               if test matches '1n0n' then test = not(not(test))
               begin case
                  case test eq 'ON' or test eq '1'
                     line = 'DBG. = @TRUE'
                  case test eq 'OFF' or test eq '0'
                     line = 'DBG. = @FALSE'
                  case 1
                     line = 'DBG. = ':rest
               end case
            end else
               if comd eq 'DBV' and rest eq '' then
                  display sysmsg(6304)<13> ;*You have not said what to put on CRT line!
                  comi = ''
                  return
               end
               if dlim ne '"' and dlim ne '\' then dlim = "'"
               line = 'IF DBG. THEN '
               if rest ne '' then line := 'CRT ':dlim:rest:' = ':dlim:':':rest
               if comd eq 'DBW' then
                  if rest ne '' then line := ': ;'
                  line := ' INPUT WAIT ; IF WAIT NE ':dlim:dlim:' THEN STOP'
               end
            end
            gosub savethat
            here += 1 ; last += 1 ; lnum += 1
            gosub insert.line
            gosub reset.record
            gosub display.line
         case comd eq 'DE'                ; * delete lines
            if viewflag then gosub viewonly ; return
            chng = 0 ; save = here
            if rest ne '' then
               patt = rest
               flag = ''
               cto = ''
               cfrom = 'DE'
               gosub cm.del.entry
               return
            end
            gosub set.bounds
            gosub delete.lines
            here = dawn
            if here gt last then
               here = last
               display sysmsg(6310,here)<19> ;*Bottom. Line  was above the last delete.
            end else
               display sysmsg(6310,here,chng)<16> ;*At line %1. Deleted %2 lines.
               gosub display.line
            end
         case comd eq 'DISPLAY'     ; * insert display line for programmer
            if viewflag then gosub viewonly ; return
            if rest eq '' then
               display sysmsg(6304)<15> ;*You have not said what to put on DISPLAY line!
               comi = ''
               return
            end
            gosub savethat
            here += 1 ; last += 1 ; lnum += 1
            if dlim ne '"' and dlim ne '\' then dlim = "'"
            line = 'DISPLAY ':dlim:rest:' = ':dlim:':':rest
            gosub insert.line
            gosub reset.record
            gosub display.line
         case comd eq 'DROP'              ; * remove the block
            if viewflag then gosub viewonly ; return
            if not(beg) and not(fin) then
               display sysmsg(6312)<2> ;*Command requests a block operation, but no block is defined.
               gosub bad.comd ; return
            end
            if beg le 1 then
               temp = 0
            end else
               temp = index(this,am,beg-1)
               if not(temp) then
                  display sysmsg(6562) ;*Cannot find beginning of block
                  gosub bad.comd ; return
               end
            end
            if fin eq last then
               temp -= 1
               temp<2> = len(this)
            end else
               temp<2> = index(this,am,fin)
            end
            if not(temp<2>) then
               display sysmsg(6563) ;* Cannot find end of block
               gosub bad.comd ; return
            end
            numb = fin - beg + 1
            if blockflag then
               if beg eq fin
                  then stub = sysmsg(6978, beg) ;*Delete line %1
                  else stub = sysmsg(6556, beg, fin) ;*Delete block from line %1 to line %2?
               gosub get.answ
               if answ ne yes then
                  display sysmsg(6312)<3> ;*Block command cancelled.
                  return
               end
            end
            dawn = beg; dusk = fin
            gosub delete.lines
            display sysmsg(6312,numb)<4> ;*Dropped (deleted) %1 lines.
            gosub display.line
         case comd eq 'DTX'               ; * decimal to hex
            if not(rest matches '1N0N' or rest matches '-1N0N') then
               display sysmsg(7278) ;*Numeric value required
               gosub bad.comd ; return
            end
            if rest gt 2147483647 or rest lt -2147484648 then
               display sysmsg(6310)<18> ;*Outside range -2147483648 to 2147484647
               gosub bad.comd ; return
            end
            crt oconv(rest,'MX')
         case comd eq 'DUP'               ; * duplicate previous line
            if viewflag then gosub viewonly ; return
            if here lt 1 then
               display sysmsg(6530) ;*No current line
               gosub bad.comd ; return
            end
            if numb eq '' and rest matches '1N0N' then numb = rest
            if numb lt 1 then numb = 1
            gosub savethat
            gosub get.line
            for xx = 1 to numb
               gosub insert.line
               last += 1
            next xx
            gosub reset.record
            display sysmsg(6310,numb,here)<17> ;*Inserted %1 copies of line %2 after line %2. Still at %2.
         case 1 ; gosub bad.command
      end case
      return

e:    begin case
         case comd eq 'EC'        ; * edit called program (in this file)
            if here lt 1 then here = 1
            gosub get.line
            convert badc to gudc in line
            line = trim(line)
            temp = upcase(line)
            good = index(temp,'CALL ',1)
            if good then line = trim(field(trim(line[good+5,huge]),';',1))
            line = trim(field(line,'(',1))
            if index(line,' ',1) then good = @false
            if line eq '' then good = @false
            if line[1,1] eq '@' then
               display sysmsg(6306)<2> ;*Leading "@" is logical pointer
               good = @false
            end
            if not(good) then
               display sysmsg(6305)<3> ;*The EC command requires lines in format ':crt '"CALL ID" or "CALL ID(..."
               gosub bad.comd ; return
            end
            good = @false
            readv temp from file, line, 1 then
               ofil = fnam
               good = @true
            end else
               readv temp from file, upcase(line), 1 then
                  ofil = fnam
                  good = @true
                  line = upcase(line)
               end
            end
            if not(good) then
               readv temp from @voc, line, 3 else
                  readv temp from @voc, upcase(line), 3
                     then line = upcase(line)
                     else temp = ''
               end
               if temp ne '' then
                  ofil = field(temp,@ds,dcount(temp,@ds)-1)
                  if upcase(ofil[4]) eq '.OUT' then
                     ofil = ofil[1,len(ofil)-4]
                  end
                  open ofil to temp then
                     readv test from temp, line, 1 then
                        good = @true
                        display sysmsg(6534,ofil)  ;*File name           = %1
                     end
                     close temp on error null
                  end
               end
            end
            if not(good) then
               display sysmsg(6306,line)<3> ;*"%1" is not in this file
               gosub bad.comd ; return
            end
            execute verb:' ':ofil:' ':line:options
            test = @(0,0)
            display sysmsg(6306,view,item,fnam)<12> ;*Back %1ing the record "%2" in file "%3"
         case comd eq 'ECS'               ; * edit command stack
            ttid = whom:'_':levl:'_commands'
            temp = raise(stak)
            write temp on acom, ttid on error display sysmsg(6304)<42> ; return ;* WRITE failure - file not updated
            display sysmsg(6306,view)<13> ;*%1ing command stack
            execute verb:' AE_COMS ':ttid:options
            test = @(0,0)
            display sysmsg(6306,view,item,fnam)<12> ;*Back %1ing the record "%2" in file "%3"
            read temp from acom, ttid else temp = ''
            temp = field(temp,am,1,staknumb-1)
            stak = lower(temp)
            delete acom, ttid
!        case comd eq 'EDITPAGE' ;* used for development
!           editpage = not(editpage)
!           if editpage then
!              begn = @(0) ; goup = @(-10)
!              prmt = '*':str('-',llen-1)
!           end else
!              begn = char(13) ; goup = ''
!              prmt = str('-',llen)
!           end
!           crt 'editpage = ':editpage
         case comd eq 'EF'                ; * edit fields
            if numb lt 0 or numb gt 255 then
               display sysmsg(6306,numb)<4> ;*%1 is outside range 0-255
               comi = ''
               return
            end
            vmrk = char(numb)
            vals = sysmsg(6306,numb)<10> ;*char{%1}
            gosub edit.fields
            vmrk = char(numb); gosub reset.fields
         case comd eq 'EI'                ; * edit included code
            if here lt 1 then here = 1
            gosub get.line
            convert badc to gudc in line
            line = field(line,';',1)
* Remove leading spaces and comment marks
            line = trim(line)
            line = trim(line,'!','L')
            line = trim(line,'*','L')
            line = trim(line)
            good = @true
            temp = upcase(field(line,' ',1))
            if temp ne 'INCLUDE' and temp ne '$INCLUDE' and temp ne '#INCLUDE' then good = @false
            line = trim(line[len(temp)+1,len(line)])
            if line[1,1] eq '<'and line[1] eq '>'     ;* C code
               then line = line[2,len(line)-2]        ;* C code
            begin case
               case dcount(line,' ') gt 3 ; good = @false
               case dcount(line,' ') eq 3
                  if field(line,' ',1) ne 'DICT' then good = @false
               case dcount(line,' ') eq 1
                  readv test from file, line, 1 then
                     line = fnam:' ':line
                  end else
                     readv test from file,upcase(line),1 then
                        line = fnam:' ':upcase(line)
                     end else
                        test = trans('SYSCOM',line,1,'X')
                        if test ne '' then
                           line = 'SYSCOM ':line
                        end else
                           test = trans('SYSCOM',upcase(line),1,'X')
                           if test ne ''
                              then line = 'SYSCOM ':upcase(line)
                              else line = fnam:' ':line
                        end
                     end
                  end
            end case
            if not(good) then
               display sysmsg(6305)<4> ;*The EI command requires lines in format ':crt '"$IN... {DICT} {FN} ID"
               gosub bad.comd ; return
            end
            execute verb:' ':line:options
            test = @(0,0)
            display sysmsg(6306,view,item,fnam)<12> ;*Back %1ing the record "%2" in file "%3"
         case comd eq 'EIT'                ; * edit i-types
            if (dprt or upcase(fprt) eq 'VOC') and here eq 2 and upcase(this[1,1]) eq 'I' else
               display sysmsg(6305)<11> ;* EIT is only for line 2 of a dictionary I-type
               return
            end
*          gosub get.line ; temp = line
            gosub get.line
            gosub split.itype
            ttid = whom:'_':levl:'_IType.in.line#':here
            write bite on acom, ttid on error gosub writerr ; return
            display sysmsg(6306,view)<5>: ;*%1ing IType as fields...
            execute verb:' AE_COMS ':ttid:options
            test = @(0,0)
            display sysmsg(6306,view,item,fnam)<12> ;*Back %1ing the record "%2" in file "%3"
            read line from acom, ttid else line = ''
            delete acom, ttid
            vmrk = ';'; gosub reset.fields
         case comd eq 'EK'                ; * edit kept buffer
            gosub get.buffer
            if bnum lt 1 then bnum = 1
            ttid = whom:'_':levl:'_keptbuffer_':bnum
            write kept(bnum) on acom, ttid on error display sysmsg(6304)<42> ; return ;* WRITE failure - file not updated
            display sysmsg(6306,view,bnum)<16>: ;*%1ing kept buffer (%2)
            execute verb:' AE_COMS ':ttid:options
            test = @(0,0)
            display sysmsg(6306,view,item,fnam)<12> ;*Back %1ing the record "%2" in file "%3"
            read kept(bnum) from acom, ttid else kept(bnum) = ''
            delete acom, ttid
         case comd eq 'EPR'               ; * edit prestores
            numb = numb + 0
            if numb lt 0 or numb gt presnumb then
               display sysmsg(6311,presnumb)<7> ;*PRestore must be in range 1-%1.
               gosub bad.comd ; return
            end
            ttid = whom:'_':levl:'_prestores'
            temp = raise(pres)
            if numb then
               bite = raise(temp<numb>)
               write bite on acom, ttid on error display sysmsg(6304)<42> ; return ;* WRITE failure - file not updated
               display sysmsg(6306,view,numb)<14>: ;*%1ing prestore %2
            end else
               write temp on acom, ttid on error display sysmsg(6304)<42> ; return ;* WRITE failure - file not updated
               display sysmsg(6306,view)<6>: ;*%1ing prestores
            end
            execute verb:' AE_COMS ':ttid:options
            test = @(0,0)
            display sysmsg(6306,view,item,fnam)<12> ;*Back %1ing the record "%2" in file "%3"
            if numb then
               read bite from acom, ttid else bite = ''
               temp<numb> = lower(bite)
            end else
               read temp from acom, ttid else temp = ''
            end
            pres = lower(temp)
            delete acom, ttid
         case comd eq 'ESS'               ; * edit search stack
            ttid = whom:'_':levl:'_searches'
            temp = raise(look)
            write temp on acom, ttid on error display sysmsg(6304)<42> ; return ;* WRITE failure - file not updated
            display sysmsg(6306,view)<15>: ;*%1ing search stack
            execute verb:' AE_COMS ':ttid:options
            test = @(0,0)
            display sysmsg(6306,view,item,fnam)<12> ;*Back %1ing the record "%2" in file "%3"
            read temp from acom, ttid else look = ''
            look = lower(temp)
            delete acom, ttid
         case comd eq 'ESV'               ; * edit subvalues
            vmrk = sm ; vals = sysmsg(6306)<7> ;*subvalues
            gosub edit.fields
            vmrk = sm; gosub reset.fields
         case comd eq 'ET'        ; * edit tags
            vals = sysmsg(6306)<32> ;* tags
            ttid = whom:'_':levl:'_':vals
            xxno = dcount(krj<1>,vm)
            temp = ''
            for xx = 1 to xxno
               temp<xx> = krj<2,xx>:' ':krj<1,xx>
            next xx
            write temp on acom, ttid on error gosub writerr ; return
            display sysmsg(6306,view,vals)<11>: ;*%1ing %2 as fields...
            execute verb:' AE_COMS ':ttid:options
            test = @(0,0)
            display sysmsg(6306,view,item,fnam)<12> ;*Back %1ing the record "%2" in file "%3"
            read temp from acom, ttid else temp = ''
            xxno = dcount(temp,am)
            krj = am:am:krj<3>
            yy = 0
            for xx = 1 to xxno
               bite = trim(temp<xx,1,1>)
               left = field(bite,' ',1)
               rest = field(bite,' ',2,99)
               if left matches '1N0N' then left += 0 else left = 0
               if left gt last then left = 0
               if left then
                  yy += 1
                  if rest eq '' then rest = 'T':left
                  krj<1,yy> = rest
                  krj<2,yy> = left
               end
            next xx
            if krj<3> gt yy then krj<3> = yy
            if krj<1> ne '' and krj<3> lt 1 then krj<3> = 1
            delete acom, ttid
         case comd eq 'EV'                ; * edit values
            vmrk = vm ; vals = sysmsg(6306)<8> ;*values
            gosub edit.fields
            vmrk = vm; gosub reset.fields
         case comd eq 'EW'     ; * edit words (as defined by wordmark)
            vmrk = wordmark ; vals = sysmsg(6306)<9> ;*words
            gosub edit.fields
            vmrk = wordmark; gosub reset.fields
* Various forms for quitting
         case comd eq 'EX' or comd eq 'EXIT' ; comd = 'Q' ; redo = @true
         case comd eq 'EXK' or comd eq 'EXITK' ; comd = 'QK' ; redo = @true
         case 1 ; gosub bad.command
      end case
      return

f:    begin case
         case comd eq 'FD'                ; * delete item
            if viewflag then gosub viewonly ; return
            if not(sec.delete.flg) then
               display sysmsg(6304)<17> ;*Delete disabled
               comi = ''
               return
            end
            gosub write.record
         case comd eq 'FILE' ; comd = 'SV' ; redo = @true
         case comd[1,2] eq 'FI'           ; * file item
            if viewflag then gosub viewonly ; return
            if not(sec.write.flg) then
               display sysmsg(6304)<18> ;*File disabled
               comi = ''
               return
            end
            temp = comd[3,len(comd)]
            convert 'BCRDL' to '' in temp
            if temp eq '' then gosub write.record else gosub bad.command
         case comd eq 'FL' or comd eq 'FLA'  ; * find labels
            gosub find.labels
*           crt
*           gosub display.line
         case comd eq 'FM' or comd eq 'FMA'       ; * find match command
            gosub find.matches
         case comd eq 'FOLD'              ; * fold the line
            if viewflag then gosub viewonly ; return
            chng = 0 ; save = here
            if dlim ne '' then fold = ''
            if rest eq '' then rest = fold
            if rest eq '' then rest = span-llen-2
            if not(rest matches '1N0N') then
               display sysmsg(6304)<19> ;*Non-numeric length - try HELP FOLD.
               comi = ''
               return
            end
            fold = rest
            gosub get.line
            display sysmsg(6310,fold)<5> ;*FOLD line to length %1
            bite = line
            gosub parse.bite
            gosub check.line
            if chng then gosub reset.record
         case comd eq 'FOR' or comd eq 'FORMAT'      ; * format this item
            gosub get.format
            if last lt 1 then return
            gosub savethat
            display sysmsg(6310,fr(1),fr(2))<6> ;*Margin=%1, Indentation=%2
            gosub indenter
            gosub set.record
         case 1 ; gosub bad.command
      end case
      return

g:    begin case
         case comd eq 'G'                 ; * Go to line
            if numb eq '' then
               if dlim eq '<' and beg ne '' then here = beg
               if dlim eq '>' and fin ne '' then here = fin
            end else here = numb
            if here gt last then here = last
            gosub display.line
         case 1 ; gosub bad.command
      end case
      return

h:    begin case
         case comd eq 'H' or comd eq 'HELP'
            gosub show.help
         case comd eq 'HEX'            ; * show this line in hexadecimal
            if not(here) then return
            gosub get.line
            temp = ''
            xxno = len(line)
            for xx = 1 to xxno
               bit = line[xx,1]
               bit = oconv(seq(bit),'MX')
               bit = fmt(bit,'R%2')
               temp<1> = temp<1>:bit[1,1]
               temp<2> = temp<2>:bit[2,1]
            next xx
            if lfmt then crt fmt(here,lfmt):': ':
            crt temp<1>
            if lfmt then crt space(llen+2):
            crt temp<2>
            temp = ''
         case comd eq 'HOLD'
            if hold ne '' then
               stub = sysmsg(6310)<44> ;* list already held. Release it (y/n)?
               gosub get.answ
               if answ eq yes then hold = ''
            end else
               hold = idlist
               display sysmsg(6310,idcnt)<43> ;* Holding %1
            end
         case 1 ; gosub bad.command
      end case
      return

i:    begin case
         case comd eq 'I'                 ; * insert lines
            if viewflag then gosub viewonly ; return
            chng = 0 ; save = here
            if rest ne '' then
               if numb lt 1 then numb = 1
               inum = numb
               gosub get.line
               if not(chng) then gosub savethis
               if here gt 0
                  then memr(cell)<lnum> := str(am:rest,inum)
                  else memr(1)<1> = str(rest:am,inum):memr(1)<1>
               if here le beg then beg += inum
               if here le fin then fin += inum
               yyno = dcount(krj<1>,vm)
               for yy = 1 to yyno
                  if krj<2,yy> gt here then krj<2,yy> += inum
               next yy
               here = here + inum
               gosub reset.record
               gosub get.line
               gosub display.line
               display sysmsg(6310,here,inum,last)<7> ;*At line %1. %2 lines inserted, bottom now at line %3.
            end else
               if nill ne '' then
                  display sysmsg(6310,nill)<8> ;*Terminate input with "%1"
               end
               loop
                  new1 = here + 1
                  stub = new1:'='
                  if lfmt then stub = fmt(new1,lfmt):'='
                  gosub get.rope; line = rope
               until line eq nill do
                  gosub parse.line
                  last += 1
                  here += 1
                  lnum += 1
                  if not(chng) then gosub savethis
                  chng += 1
                  gosub insert.line
                  temp = len(last)
                  if lfmt then
                     if temp gt 3 and temp ne llen then gosub get.lfmt
                  end
                  if line eq nill then
                     crt begn:
                     if lfmt then crt fmt(new1,lfmt):'= ':
                  end
                  crt
                  numb -= 1
                  if numb eq 0 then exit
               repeat
               crt begn:ceol:
            end
            if chng then gosub reset.record
         case comd eq 'IC'                ; * iconv
            if viewflag then gosub viewonly ; return
            if rest eq '' then
               display sysmsg(6304)<20> ;*No conversion given
               gosub bad.comd ; return
            end
            ccom = '*':rest ; gosub conv.command
         case comd eq 'IN'                ; * insert from execute
            if viewflag then gosub viewonly ; return
            if trim(rest) eq '' then
               display sysmsg(6304)<21> ;*No external command given
               comi = '' ; return
            end
            execute rest capturing bite
            test = @(0,0)
            numb = dcount(bite,am)
            if numb then
               gosub savethat
               this = insert(this,here+1,0,0,bite)
               gosub set.record
               display sysmsg(6310,numb,here)<9> ;*Inserted %1 lines; still at line %2.
            end else
               display sysmsg(6309)<4> ;*Nothing done - no output from command.
               comi = '' ; return
            end
         case 1 ; gosub bad.command
      end case
      return

j:    begin case
         case comd eq 'J'                 ; * join lines
            if viewflag then gosub viewonly ; return
            if dlim ne '' then
               line = rest ; gosub parse.line ; join = line
            end
            if here and here lt last then
               chng = 0 ; save = here
               gosub get.line
               test = line
               here += 1
               gosub set.bounds
               for here = dawn to dusk
                  gosub get.line
                  test = test:join:line
               next here
               gosub delete.lines
               if chng eq 0 then return
               here = save
               ooph = here
               gosub get.line
               memr(cell)<lnum> = test
               gosub reset.record
            end
            gosub display.line
         case 1 ; gosub bad.command
      end case
      return

k:    begin case
         case comd eq 'KEEP' or comd eq 'KEEPA'
            gosub get.buffer
            if bnum lt 1 then bnum = 1
            gosub get.load
            if temp eq '' then return
            if comd[len(comd),1] ne 'A' then
               gosub get.lines
               if not(temp) then return
            end
            kept(bnum) = temp
            temp = dcount(temp,am)
            display sysmsg(6312,here,temp,'(1)')<27> ;*At line %1, %2 lines loaded.
            temp = ''
         case comd eq 'KEPT' or comd eq 'K' ; * display kept
            gosub get.buffer
            disp = ''
            if bnum then
               xxno = dcount(kept(bnum),am)
               if xxno ge 1 then
                  bit = len(xxno)
                  disp = sysmsg(6312,bnum,xxno)<24> ;****** Contents of KEPT%1 buffer (%1 lines) *****
                  stub = sysmsg(6312,bnum)<25> ;*Press return to continue showing KEPT buffer, Q to quit
                  for xx = 1 to xxno
                     temp = oconv(kept(numb)<xx>,'MCP')[1,wide-bit-1]
                     disp<-1> = fmt(xx,'R#':bit):':':temp
                  next xx
               end
            end else
               for xx = 1 to 9
                  if kept(xx) ne '' then
                     xxno = dcount(kept(xx),am)
                     disp<-1> = sysmsg(6312,xx,xxno)<24> ;****** Contents of KEPT%1 buffer (%2 lines) *****
                  end
               next xx
            end
            if disp eq '' then disp = sysmsg(6312,bnum)<23> ;*Nothing in KEPT buffer
            gosub show.disp
         case 1 ; gosub bad.command
      end case
      return

l:    begin case
!         case index('\L\LN\LA\LNA\LAN\','\':comd:'\',1)   ; * list or locate
!         case convert('NAW','',comd) eq 'L'   ; * list or locate
         case convert('NAWR','',comd) eq 'L'   ; * list or locate
            if index(comd,'R',1) and index(comd,'W',1) then
               display sysmsg(6304)<44> ;*You cannot search 'W'orking and 'R'emark lines at the same time
               gosub bad.comd ; return
            end
            if upcase(comi) eq 'L' then
               if look<1,1> eq '' then
                  display sysmsg(6304)<16> ;*No previous locate command to repeat.
                  comi = ''
                  return
               end
               comi = look<1,1>
               gosub parse.command
               if comd eq '' then comd = 'L' ; numb = huge
               redo = @true
               return
            end
            finder = ''
            seeker = dlim
            convert '|+#' to '!&^' in seeker
            if index('!^&',seeker,1) then
               finder = rest
               convert dlim to am in finder
               if finder<2> eq '' then finder = '' else rest = finder<1>
            end
            looper = dcount(finder,am)
            if rest ne '' then
               if field(rest,dlim,2) eq '*' then
                  rest = field(rest,dlim,1)
                  cols = '*'
               end else
                  gosub parse.cols
                  if not(good) then return
               end
            end else
               if dlim ne '' then
                  display sysmsg(6304)<8> ;*The second field is empty.
                  gosub bad.comd ; return
               end
               cols = ''
            end
            if index(comd,'A',1) then
               bump = -1
               dawn = here - 1
               if dawn lt 1 then dawn = 1
               if numb then dusk = here - numb + 1 else dusk = 1
               if dusk lt 1 then dusk = 1
            end else
               bump = 1
               dawn = here + 1
               if dawn gt last then dawn = 1
               if numb then dusk = dawn + numb - 1 else dusk = last
               if dusk gt last then dusk = last
            end
            if looper then rest = finder else looper = 1
            line = rest ; gosub parse.line ; rest = line
            lastfind = rest<1>
            if not(caseflag) then rest = upcase(rest)
            if spaceflag else convert ' ':char(9) to '' in rest
            for here = dawn to dusk step bump
               gosub get.line
               if index(comd,'W',1) then
! Subtle thing here when the line is a label followed by a comment
! EVEN MORE subtle is a label, code, a semicolon, and a comment
! NOT DEALT WITH, I'm afraid
                  test = upcase(trim(line)[1,4])
                  if test eq 'REM ' then continue
                  test = test[1,1]
                  if test eq '*' or test eq '!' then continue
               end
               if index(comd,'R',1) then
                  test = upcase(trim(line)[1,4])
                  if test ne 'REM ' then
                     test = test[1,1]
                     if test ne '*' and test ne '!' then continue
                  end
               end
               if cols then
                  if cols eq '*'
                     then line = field(field(line,'*',1),'!',1)
                     else line = line[cols,colf]
               end
               if caseflag then temp = line else temp = upcase(line)
               if spaceflag else convert ' ':char(9) to '' in temp
               badder = @false ; gooder = @false
               begin case
                  case seeker eq ':'
                     if temp[1,len(rest<1>)] eq rest<1>
                        then good = @true
                        else good = @false
                  case seeker eq ';'
                     if temp[len(rest<1>)] eq rest<1>
                        then good = @true
                        else good = @false
                  case 1
                     if index(temp,rest<1>,1)
                        then good = @true
                        else good = @false
                     for xx = 2 to looper
                        if index(temp,rest<xx>,1)
                           then gooder = @true
                           else badder = @true
                     next xx
               end case
               test = index(comd,'N',1)
               begin case
                  case seeker eq '^' and not(test)
                     if good and not(gooder)
                        then good = @true
                        else good = @false
                  case seeker eq '^' and test
                     if not(good) and not(badder)
                        then good = @true
                        else good = @false
                  case seeker eq '!' and not(test)
                     if good or gooder
                        then good = @true
                        else good = @false
                  case seeker eq '!' and test
                     if not(good) and not(gooder)
                        then good = @true
                        else good = @false
                  case seeker eq '&' and not(test)
                     if good and gooder
                        then good = @true
                        else good = @false
                  case seeker eq '&' and test
                     if not(good) and badder
                        then good = @true
                        else good = @false
                  case test
                     good = not(good)
               end case
               if good then
                  gosub display.line
                  if not(numb) then exit
               end
            next here
            if numb then here = dusk
            display sysmsg(6310,here)<10>: ;*Now at line %1
            if here eq last then display sysmsg(6304)<22>: ;* (bottom)
            crt '.'
            if rest ne '' and comi ne '' and comi ne look<1,1> then
               look = insert(look,1,1,0,comi)
               look = field(look,vm,1,looknumb)
            end
         case comd eq 'LC' or comd eq 'LCF' ; * lower case (make line in)
            if viewflag then gosub viewonly ; return
            if comd eq 'LCF' then ccom = 'MCL' else ccom = 'QMCL'
            gosub conv.command
* Various forms for loading stuff
         case comd eq 'LD' or comd eq 'LOAD' or comd eq 'LDA' or comd eq 'LOADA'
            if viewflag then gosub viewonly ; return
            gosub load.item
         case comd eq 'LL'                ; * long lines
            if not(rest matches '1N0N') then
               rest = span-llen-2
               crt 'LL':numb:'/':rest
            end
            dawn = here + 1
            if dawn gt last then dawn = 1
            if numb then dusk = here + numb else dusk = last
            if dusk gt last then dusk = last
            for here = dawn to dusk
               gosub get.line
               temp = trim(line[rest,huge])
               if temp ne '' then
                  gosub display.line
                  if not(numb) then return
               end
            next here
            crt
            gosub display.line
         case 1 ; gosub bad.command
      end case
      return

m:    begin case
         case comd eq 'M'         ; * pattern matching
            rest = field(rest,dlim,1)
            if rest eq '' and mmat ne '' then
               dlim = mmat<1,1>
               rest = mmat<1,2>
            end
            if rest eq '' then
               display sysmsg(6304)<24> ;*No pattern given to match
               return
            end
            gosub changematch.command
         case comd eq 'MACRO'
            if macn then
               temp = dcount(macc<1,1>,sm)
               macc = delete(macc,1,1,temp)
               macc = delete(macc,1,1,temp)
               if macc ne '' then
                  pres<1,macn> = macc<1,1>
                  display sysmsg(6311,macn)<2> ;*Macro saved to PRestore %1
               end else
                  display sysmsg(6311)<3> ;*Macro empty - not saved
               end
               macc = ''
               macn = 0
            end else
               if numb eq '' then numb = 1
               if numb gt presnumb or numb lt 1 then
                  display sysmsg(6311,presnumb)<4> ;*PRestore must be in range 1-%1.
                  comi = ''
                  return
               end
               display sysmsg(6311,numb)<5> ;*Macro being recorded for PRestore %1
               macn = numb
            end
         case comd eq 'MERGE' or comd eq 'ME'      ; * merge stuff
            if viewflag then gosub viewonly ; return
            if rest eq '' and numb eq '' then
               if not(beg) and not(fin) then
                  display sysmsg(6312)<2> ;*Command requests a block operation, but no block is defined.
                  gosub bad.comd ; return
               end
               numb = fin - beg + 1
               if blockflag then
                  if beg eq fin
                     then stub = sysmsg(6977,beg,here) ;*Copy line %1 to under line %2?
                     else stub = sysmsg(6554,beg,fin,here) ;*Copy lines %1-%2 to under line %3?
                  gosub get.answ
                  if answ ne yes then
                     display sysmsg(6312)<3> ;*Block command cancelled.
                     return
                  end
               end
               rest = beg:' ':fin
               numb = ''
            end
            gosub parse.nums
            if not(rest) or not(numb) then
               display sysmsg(6305)<5> ;*Format of MErge command is: "MEn/n"; eg: "ME10/15" or "ME/n/m"; eg: "ME/15/24"
               gosub bad.comd ; return
            end
            bite = field(this,am,rest,numb)
            if numb ne 1 or bite ne '' then numb = dcount(bite,am)
            if numb then
               gosub savethat
               this = insert(this,here+1,0,0,bite)
               gosub set.record
               if beg gt here then beg = beg + numb
               if fin gt here then fin = fin + numb
               xxno = dcount(krj<1>,vm)
               for xx = 1 to xxno
                  if krj<2,xx> gt here then krj<2,xx> += numb
               next xx
               display sysmsg(6310,numb,rest,here)<12> ;*Merged %1 lines starting at line %2; still at line %3.
            end else
               display sysmsg(6309)<5> ;*Nothing done - this line is within the range.
               comi = '' ; return
            end
         case comd eq 'MOVE' or comd eq 'MV'       ; * move stuff
            if viewflag then gosub viewonly ; return
            if rest eq '' then
               if not(beg) and not(fin) then
                  display sysmsg(6312)<2> ;*Command requests a block operation, but no block is defined.
                  gosub bad.comd ; return
               end
               if here le fin and here ge beg then
                  display sysmsg(6312)<5> ;*A block may not be moved into itself. MERGE will work.
                  comi = ''
                  return
               end
               numb = fin - beg + 1
               if blockflag then
                  if beg eq fin then
                     stub = sysmsg(6312,beg,here,ny)<6> ;*Move line %1 to after line %2 OK? %3
                  end else
                     stub = sysmsg(6312,beg,fin,here,ny)<7> ;*Move lines %1-%2 to after line %3 OK? %4
                  end
                  gosub get.answ
                  if answ ne yes then
                     display sysmsg(6312)<3> ;*Block command cancelled.
                     return
                  end
               end
               dlim = ' '
               rest = beg:' ':fin
               numb = ''
            end
            gosub parse.nums
            if not(rest) or not(numb) then
               display sysmsg(6305)<6> ;*Format of MoVe command is: "MVn/n"; eg: "MV10/15" or "MV/n/m"; eg: "MV/15/24"
               gosub bad.comd ; return
            end
            dusk = rest + numb - 1
            if dusk gt last then dusk = last
            if here ge rest and here le dusk then
               display sysmsg(6309)<5> ;*Nothing done - this line is within the range.
               comi = '' ; return
            end
            bite = field(this,am,rest,numb)
            numb = dcount(bite,am)
            if numb then
               gosub savethat
               if here gt dusk then
                  this = insert(this,here+1,0,0,bite)
                  if rest gt 1
                     then this = this[1,col1()-1]:this[col2(),len(this)]
                     else this = this[col2()+1,len(this)]
               end else
                  this = this[1,col1()-1]:this[col2(),len(this)]
                  this = insert(this,here+1,0,0,bite)
               end
               gosub set.record
               if here gt dusk then
                  here = here - numb
                  display sysmsg(6310,numb,rest,here)<13> ;*Moved %1 lines starting at line %2; now at line %3.
               end else
                  display sysmsg(6310,numb,rest,here)<14> ;*Moved %1 lines starting at line %2; still at line %3.
               end
               posn = beg; gosub recalc.posn; beg = posn
               posn = fin; gosub recalc.posn; fin = posn
               xxno = dcount(krj<1>,vm)
               for xx = 1 to xxno
                  posn = krj<2,xx>; gosub recalc.posn; krj<2,xx> = posn
               next xx
            end else
               display sysmsg(6309)<3> ;*Nothing done - no lines selected.
               comi = '' ; return
            end
         case 1 ; gosub bad.command
      end case
      return

n:    begin case
         case comd eq 'N'                 ; * same as "+"
            if numb eq '' then numb = 1
            here = here + numb
            if here gt last then here = last
            gosub display.line
         case comd eq 'NULL'              ; * null line input definition
            dlim = trim(dlim):trim(rest)
            dlim = dlim[1,1]
            nill = dlim
            if nill eq '"' then
               bit = "'":nill:"'"
            end else bit = '"':nill:'"'
            display sysmsg(6310,bit)<15> ;*NULL character to terminate INSERT is %1.
            comi = ''
         case comd eq 'NUM'               ; * toggle the line numbering
            if lfmt eq '' then
               display sysmsg(6308)<6> ;*Line Numbering is ON
               gosub get.lfmt
            end else
               display sysmsg(6308)<7> ;*Line Numbering is OFF
               lfmt = ''
            end
         case 1 ; gosub bad.command
      end case
      return

o:    begin case
         case comd eq 'OC'                ; * oconv
            if viewflag then gosub viewonly ; return
            if rest eq '' then
               display sysmsg(6308)<8> ;*No conversion given
               gosub bad.comd ; return
            end
            ccom = rest ; gosub conv.command
         case comd[1,2] eq 'OO'           ; * undo last change
            if oopc ne '' then
               this = oops
               here = ooph
               last = dcount(this,am)
               beg = oopb
               fin = oopf
               krj = oopk
               gosub set.record
               display sysmsg(6308,oopc,here)<9> ;*"%1" undone - now at line %2.
               oops = '' ; oopc = '' ; ooph = ''
               oopb = '' ; oopf = '' ; oopk = ''
               gosub display.line
            end else
               display sysmsg(6308)<10> ;*last change already "undone" or nothing to undo
            end
            comi = ''
         case comd eq 'OUT'
            hard = @false
            gosub outline
            crt
            gosub display.line
         case 1 ; gosub bad.command
      end case
      return

p:    begin case
         case comd eq 'P'                 ; * page on
            if numb else numb = plen
            if here ge last then here = 0
            here += 1
            gosub set.bounds
            for here = dawn to dusk
               gosub display.line
            next here
            here = dusk
         case comd eq 'PA'                ; * print window up to here
            if numb else numb = pwin
            save = here
            here = here - numb
            gosub set.bounds
            for here = dawn to dusk
               gosub display.line
            next here
            here = save
            display sysmsg(6310,here)<21> ;*Still at line %1.
         case comd eq 'PASTE' and rest eq ''  ; * paste from kept
            if viewflag then gosub viewonly ; return
            gosub get.buffer
            if bnum lt 1 then bnum = 1
            if kept(bnum) eq '' then
               display sysmsg(6312,bnum)<23> ;*Nothing in KEPT buffer
               comi = '' ; return
            end
            gosub savethat
            numb = dcount(kept(bnum),am)
            this = insert(this,here+1,0,0,kept(bnum))
            gosub set.record
            display sysmsg(6312,numb,bnum,here)<26> ;*Pasted %1 lines from KEPT buffer; still at line %2.
            if beg gt here then beg += numb
            if fin gt here then fin += numb
            xxno = dcount(krj<1>,vm)
            for xx = 1 to xxno
               if krj<2,xx> gt here then krj<2,xx> += numb
            next xx
         case comd eq 'PASTE'                          ; * save the kept buffer
            if viewflag then gosub viewonly ; return
            gosub get.buffer
            if bnum lt 1 then bnum = 1
            if kept(bnum) eq '' then
               display sysmsg(6312,bnum)<23> ;*Nothing in KEPT buffer
               comi = '' ; return
            end
            gosub save.stuff
         case comd eq 'PE'                ; * page editor mode
            if not(editpage) then
               display sysmsg(6304)<25> ;*Page editing not available
               comi = ''
               return
            end
            that = this ; site = here
            if this eq '' then this = am
            if here lt 1 then here = 1
            scat = @false
            if not(viewflag) and mouser ne '' then crt mouse.on ; scat = @true
            ptop = here
            mode = 'PAGE':am:'View'
            if sec.write.flg then mode<2> = 'Ins'
            pchr = 1
            chng = '' ; show = ''
            gosub display.page
            gosub get.line
            mine = line
         case comd eq 'PL'                ; * print window from here
            if numb else numb = pwin
            save = here
            gosub set.bounds
            for here = dawn to dusk
               gosub display.line
            next here
            here = save
            display sysmsg(6310,here)<21> ;*Still at line %1.
         case comd eq 'PP'                ; * print window bracketing here
            if numb else numb = pwin
            save = here
            here = here - int(numb/2)
            gosub set.bounds
            for here = dawn to dusk
               gosub display.line
            next here
            here = save
            display sysmsg(6310,here)<21> ;*Still at line %1.
         case comd eq 'PR'                ; * prestore processing
            if numb eq '' then
               if pres ne '' then
                  display sysmsg(6311,presnumb)<6> ;*Defined prestores (%1 Maximum)
                  for xx = presnumb to 1 step -1
                     temp = pres<1,xx>
                     if temp ne '' then
                        convert sm to comdmark in temp
                        crt fmt(xx,'R%2'):' ':temp
                     end
                  next xx
               end else
                  display sysmsg(6311)<16> ;* there are no defined prestores
               end
               return
            end
            if numb gt presnumb or numb lt 1 then
               display sysmsg(6311,presnumb)<7> ;*PRestore must be in range 1-%1.
               comi = ''
               return
            end
            if dlim ne '' then
               if not(rest eq rest<1,1,1>) then
                  display sysmsg(6311)<8> ;*Invalid - delimiter in prestore
                  comi = ''
                  return
               end
               pres<1,numb> = change(rest,dlim,sm)
            end else
               salt = pres<1,numb>
            end
         case 1 ; gosub bad.command
      end case
      return

q:    begin case
* Various forms for quitting
         case comd eq 'Q' or comd eq 'QK' or comd eq 'QUIT' or comd eq 'QUITK'
            begin case
* OK if in view mode
               case viewflag ; stopsign = @true
* ok if unchanged
               case orig eq this ; stopsign = @true
* ok if ony change is FORMATting
               case upcase(oopc)[1,3] eq 'FOR' and orig eq oops ; stopsign = @true
            end case

            if not(stopsign) then
               stub = sysmsg(6304)<26> ;****** Record changed --- OK to Quit? (N/Y)>
               gosub get.answ
               if answ eq yes then stopsign = @true
            end

            if stopsign then
               if orig eq '' then
                  display sysmsg(6308,item,fnam)<11> ;*Quit "%1" in file "%2" not created.
               end else display sysmsg(6308,item,fnam)<12> ;*Quit "%1" in file "%2" unchanged.
               if index(comd,'K',1) then
                  killsign = @true
                  if idcnt gt 1 then display sysmsg(6304)<27> ;*Select list cancelled.
               end
            end
         case comd eq 'Q':am
            stopsign = @true
            killsign = @true
$ifdef QM
         case comd eq 'QS' or comd eq 'QSORT'     ; * sort the block using !SORT
            if viewflag then gosub viewonly ; return
            if not(beg) and not(fin) then
               display sysmsg(6312)<2> ;*Command requests a block operation, but no block is defined.
               gosub bad.comd ; return
            end
            if beg le 1 then
               temp = 0
            end else
               temp = index(this,am,beg-1)
               if not(temp) then
                  display sysmsg(6312)<8> ;*Cannot find beginning of block
                  gosub bad.comd ; return
               end
            end
            sole = index(comd,'U',1)
            rest = trim(upcase(rest))[1,2]
            if rest eq '' then rest = 'AL'
            if caseflag else rest := 'C'
            rest = upcase(rest)
            if convert('ACDFLRNUX','',rest) ne '' then
               display sysmsg(3275)
               gosub bad.comd ; return
            end
            temp<2> = index(this,am,fin)
            if fin eq last then temp<2> = len(this)+1
            if not(temp<2>) then
               display sysmsg(6312)<10> ;*Cannot find end of block
               gosub bad.comd ; return
            end
            if blockflag then
               stub = sysmsg(6312, beg, fin)<28> ;*Sort block beginning at %1 and ending at %2?
               gosub get.answ
               if answ ne yes then
                  display sysmsg(6312)<3> ;*Block command cancelled.
                  return
               end
            end
            gosub savethat
            temp = field(this,@am,beg,fin-beg+1)
            call !sort(temp,temp,rest)
            left = field(this,@am,1,beg-1)
            rite = field(this,@am,fin+1,*)
            this = left
            if this ne '' then this := @am
            this := temp
            if rite ne '' then this := @am
            this := rite
* If any tags are in the sorted block then clear the tags,
* as it really makes no sense to try and sort them.
            good = @true
            xxno = dcount(krj<1>,vm)
            for xx = 1 to xxno
               posn = krj<2,xx>
               if posn ge beg and posn le fin then good = @false
            next xx
            if not(good) then
               krj = ''
               display sysmsg(6306)<20> ;*Tags cleared
            end
* We may have introduced or deleted field marks
            fin = beg + dcount(temp,@am) - 1
            temp = ''
            gosub set.record
            gosub display.line
$endif
         case 1 ; gosub bad.command
      end case
      return

r:    begin case
         case comd eq 'RA'                ; * view or repeat change
            if viewflag then gosub viewonly ; return
            gosub change.command
         case comd eq 'R' and trim(dlim) ne '' and index(rest,dlim,1) ; * change
            if viewflag then gosub viewonly ; return
            crt ; comd = 'C'
            gosub change.command
         case comd eq 'R'                 ; * replace lines
            if viewflag then crt ; gosub viewonly ; return
            if not(last) then
               display sysmsg(6304)<28> ;*Empty record, use Insert (I) command.
               comi = ''
               return
            end
            if here lt 1 then here = 1 ; gosub display.line
            chng = 0 ; save = here
            if numb lt 1 then numb = 1
            if dlim ne '' and rest = '' then rest = ' '
            loop
               crt begn:
               if lfmt then crt fmt(here,lfmt):'=':
               crt ceop:
               if rest eq '' then
                  stub = here:'='
                  if lfmt then stub = fmt(here,lfmt):'='
                  gosub get.rope; line = rope
               end else line = rest
               gosub parse.line
            until line eq '' do
               crt goup:begn:ceol:
               if lfmt then crt fmt(here,lfmt):': ':
               crt line
               if line eq comdmark then
                  line = ''
                  crt begn:
                  if lfmt then crt fmt(here,lfmt):': ':
               end
               if numb gt 1 then crt
               if line eq ' ' then line = ''
               if not(chng) then gosub savethis
               chng += 1
               memr(cell)<lnum> = line
               here += 1 ; numb -= 1
               gosub get.line
               if numb eq 0 then exit
            repeat
            if here ne save then here -= 1
            if chng then gosub reset.record; gosub get.line
            crt begn:ceol:
         case comd eq 'RELEASE'           ; * release the item lock
            release file,item
            lock = @false
         case 1 ; gosub bad.command
      end case
      return

s:    begin case
         case comd eq 'S'                 ; * search processing
            if numb eq '' then
               numb = dcount(look<1>,vm)
               if numb then
                  display sysmsg(6308,numb)<13> ;*Last %1 searches
                  for xx = looknumb to 1 step back
                     if look<1,xx> ne ''
                        then crt fmt(xx,'R%2'):' ':look<1,xx>
                  next xx
               end else
                  display sysmsg(6308)<32> ;* there are no prior searches
               end
               return
            end
            if numb gt looknumb or numb lt 1 then
               display sysmsg(6308,looknumb)<14> ;*Search must be in range 1-%1.
               comi = ''
               return
            end
            comi = look<1,numb>
            if comi eq '' then
               display sysmsg(6308,numb)<15> ;*There is no search number %1.
               return
            end
            look = delete(look,1,numb,0)
            look = insert(look,1,1,0,comi)
            gosub parse.command
            if comd eq '' then comd = 'L' ; numb = huge
            comi = ''
            redo = @true
         case comd eq 'SAVE' or comd eq 'SV'         ; * save the item
            if viewflag then gosub viewonly ; return
            comd = 'SV'
            if rest eq '' then
               if not(sec.write.flg) then
                  display sysmsg(6304)<29> ;*File disabled
                  comi = ''
                  return
               end
               gosub write.record
            end else gosub save.stuff
         case comd eq 'SEQ'               ; * build a sequence
            if viewflag then gosub viewonly ; return
            if dlim eq '' then
               display sysmsg(6304)<33> ;*Too few fields in this command.
               gosub bad.comd ; return
            end
            good = @true
            cfrom = field(rest,dlim,1)
            cto = field(rest,dlim,2)
            if cto eq '' then cto = 1
            if not(num(cto)) then
               display sysmsg(6304)<34> ;*Base for sequence command must be a number.
               good = @false
            end
            bit = field(rest,dlim,3)
            if bit eq '' then bit = 1
            if not(num(bit)) then
               display sysmsg(6304)<35> ;*Increment for sequence command must be a number.
               good = @false
            end else
               if not(bit) then
                  display sysmsg(6304)<36> ;*Increment for sequence command must not be zero.
                  good = @false
               end
            end
            if not(good) then gosub bad.comd ; return
            rest = dlim:field(rest,dlim,4,2)
            if rest ne dlim then
               gosub parse.cols
               if not(good) then return
            end else cols = ''
            chng = 0 ; save = here
            gosub set.bounds
            for here = dawn to dusk
               gosub get.line ; temp = line
               if cols then
                  bite = index(line[cols,colf],cfrom,1)
                  if bite then bite = bite + cols - 1
               end else
                  bite = index(line,cfrom,1)
               end
               if bite then
                  temp = line[1,bite-1]:cto
                  temp = temp:line[bite+len(cfrom),len(line)]
               end
               if '*':temp ne '*':line then
                  cto = cto + bit
                  if not(chng) then gosub savethis
                  chng += 1
                  memr(cell)<lnum> = temp
                  gosub display.line
               end
            next here
            here = dusk
            if chng then gosub reset.record
         case comd eq 'SHOW'              ; * show changes flag
            rest = trim(upcase(rest))
            begin case
               case rest eq 'ON' ; shew = @true
               case rest eq 'OFF' ; shew = @false
               case 1 ; shew = not(shew)
            end case
            if shew
               then display sysmsg(6308)<17> ;*Show changes flag is ON
               else display sysmsg(6308)<18> ;*Show changes flag is OFF
         case comd eq 'SORT' or comd eq 'SORTU'     ; * sort the block
            if viewflag then gosub viewonly ; return
            if not(beg) and not(fin) then
               display sysmsg(6312)<2> ;*Command requests a block operation, but no block is defined.
               gosub bad.comd ; return
            end
            if beg le 1 then
               temp = 0
            end else
               temp = index(this,am,beg-1)
               if not(temp) then
                  display sysmsg(6312)<8> ;*Cannot find beginning of block
                  gosub bad.comd ; return
               end
            end
            sole = index(comd,'U',1)
            rest = trim(upcase(rest))[1,2]
            if rest eq '' then rest = 'AL'
            if not(index('*AR*AL*DR*DL*','*':rest:'*',1)) then
               display sysmsg(6312)<9> ;*Invalid sort sequence - use "AL" "AR" "DL" or "DR"
               gosub bad.comd ; return
            end
            temp<2> = index(this,am,fin)
            if fin eq last then temp<2> = len(this)+1
            if not(temp<2>) then
               display sysmsg(6312)<10> ;*Cannot find end of block
               gosub bad.comd ; return
            end
            if blockflag then
               stub = sysmsg(6312, beg, fin)<28> ;*Sort block beginning at %1 and ending at %2?
               gosub get.answ
               if answ ne yes then
                  display sysmsg(6312)<3> ;*Block command cancelled.
                  return
               end
            end
            gosub savethat
            bits = ''
            for here = beg to fin
               gosub get.line
               locate(line,bits;posn;rest) then
                  if sole then good = @false else good = @true
               end else good = @true
               if good then bits = insert(bits,posn;line)
            next here
            here = ooph
            if fin ne last
               then this = this[1,temp<1>]:bits:am:this[temp<2>+1,len(this)]
               else this = this[1,temp<1>]:bits
            bits = ''
            gosub set.record
* If any tags are in the sorted block then clear the tags,
* as it really makes no sense to try and sort them.
            good = @true
            xxno = dcount(krj<1>,vm)
            for xx = 1 to xxno
               posn = krj<2,xx>
               if posn ge beg and posn le fin then good = @false
            next xx
            if not(good) then
               krj = ''
               display sysmsg(6306)<20> ;*Tags cleared
            end
            gosub display.line
         case comd eq 'SPACE'               ; * change spacing flag for 'L'
            rest = trim(upcase(rest))
            begin case
               case rest eq 'ON' ; spaceflag = @true
               case rest eq 'OFF' ; spaceflag = @false
               case 1 ; spaceflag = not(spaceflag)
            end case
            if spaceflag then
               display sysmsg(6308)<19> ;*SPACE flag is ON
            end else display sysmsg(6308)<20> ;*SPACE flag is OFF
         case comd eq 'SPOOL'             ; * print
            if numb eq '' and rest matches '1N0N' then numb = rest
            if numb eq '' then here = 1 ; numb = last
            gosub set.bounds
            gosub spool.item
            if dawn ne 1 or dusk ne last then
               display sysmsg(6308,dawn,dusk)<22>: ;*Lines %1 to %2 of
            end
            display sysmsg(6308,item)<23> ;*"%1" spooled to the printer.
         case comd eq 'SPOOLHELP'         ; * print the help
            rest = am
            gosub show.help
         case comd eq 'SPOUT'             ; * spool outline
            hard = @true
            gosub outline
         case comd eq 'STAMP'             ; * stamp it
            if viewflag then gosub viewonly ; return
            gosub savethat
            last += 1 ; here += 1 ; lnum += 1
            line = sysmsg(6308,name,acct,timedate())<24> ;** Last updated by %1 in account %2 at %3
            gosub insert.line
            gosub reset.record
            gosub display.line
         case 1 ; gosub bad.command
      end case
      return

t:    begin case
         case comd eq 'T'                 ; * top
            here = 0
            gosub display.line
         case comd eq 'TC' or comd eq 'TCF' ; * text case (make line in)
            if viewflag then gosub viewonly ; return
            if comd eq 'TCF' then ccom = 'MCT' else ccom = 'QMCT'
            gosub conv.command
* Various ways to TRIM the line
         case comd eq 'TRIM' or comd eq 'TRIMF' or comd eq 'TRIMB'
            if viewflag then gosub viewonly ; return
            chng = 0 ; save = here
            if rest and comd eq 'TRIM' then
               seek = field(rest,dlim,1)
               if seek matches '3n' then seek = char(seek)
               mark = field(rest,dlim,2)
               mark = upcase(trim(mark))[1,1]
               if index('ABCDEFLRT',mark,1) else
                  display sysmsg(6310)<41> ;*Invalid TRIM argument
                  gosub bad.comd ; return
               end
            end else seek = ''
            show = shew ; dnum = 1
            if numb eq '' and rest matches '1N0N' then numb = rest
            gosub set.bounds
            for here = dawn to dusk
               gosub get.line
               begin case
                  case comd eq 'TRIM'
                     if seek eq ''
                        then mine = trim(line)
                        else mine = trim(line,seek,mark)
                  case comd eq 'TRIMF' ; mine = trimf(line)
                  case comd eq 'TRIMB' ; mine = trimb(line)
               end case
               gosub check.line
            next here
            here = dusk
            if chng then
               gosub reset.record
               display sysmsg(6310,chng,here)<22> ;*%1 lines changed - now at %2
            end
         case comd eq 'TWIN' or comd eq 'TRIPLE' ; * sideways cloning of line
            if viewflag then gosub viewonly ; return
            if dlim ne '' then
               line = rest ; gosub parse.line ; join = line
            end
            if here and here le last else return
            chng = 0 ; save = here
            gosub set.bounds
            for here = dawn to dusk
               gosub get.line
               if comd eq 'TWIN'
                  then test = line:join:line
                  else test = line:join:line:join:line
               if test ne line then
                  chng += 1
                  memr(cell)<lnum> = test
               end
            next here
            if chng eq 0 then return
            temp = sysmsg(6308,chng)<31> ;*Split %1 lines
            if join ne '' then temp := sysmsg(6308,join)<32> ;*, and joined the parts with %1
            crt temp
            here = save
            gosub savethat
            gosub reset.record
            gosub display.line
         case 1 ; gosub bad.command
      end case
      return

u:    begin case
         case comd eq 'U'                 ; * same as "-"
            if numb eq '' then numb = 1
            here = here - numb
            if here lt 0 then here = 0
            if here gt last then here = last
            gosub display.line
         case comd eq 'UC' or comd eq 'UCF' ; * upper case (make line in)
            if viewflag then gosub viewonly ; return
            if comd eq 'UCF' then ccom = 'MCU' else ccom = 'QMCU'
            gosub conv.command
         case comd eq 'UK'                ; * User Key Definitions
            if numb eq '' then
               display sysmsg(6310)<48>   ;*Key String
               for xx = 1 to 8
                  crt fmt('F':xx+4,'R#3'):' ':ukey<1,xx>
               next xx
               return
            end
            if numb gt 12 or numb lt 5 then
               display sysmsg(6310)<49> ;*You can only set function keys 5 to 12.
               comi = ''
               return
            end
            ukey<1,numb-4> = rest
            crt fmt('F':numb,'R#3'):' ':rest
         case comd eq 'UNLOAD' ; comd = 'SV' ; redo = @true
            if viewflag then gosub viewonly ; return
         case 1 ; gosub bad.command
      end case
      return

v:    begin case
         case comd eq 'V'                 ; * version information
            crt (upcase(verb):' = ') 'R#20':help.def
$ifdef qm
            temp = trans('NEWVOC','$RELEASE',2,'X')
            if temp eq '' then temp = trans('VOC','$RELEASE',2,'X')
            if temp eq '' then temp = '?'
            crt ('QM = ') 'R#20':temp
            crt ('Licence = ') 'R#20':system(31)
$endif
$ifdef unidata
            crt '    UniData version ':oconv('version','TVOC;X;;1')
$endif
$ifdef universe
            temp =  oconv('RELLEVEL','TNEWACC;X;;2')
            if temp eq '' then temp = oconv('RELLEVEL','TVOC;X;;2')
            if temp eq '' then temp = '?'
            crt '   UniVerse version ':temp
$endif
         case 1 ; gosub bad.command
      end case
      return

w:    begin case
         case comd eq 'W' or comd eq 'WHERE'      ; * what we are editing
            crt
            if viewflag
               then display sysmsg(6308,item,fnam)<25> ;*Viewing "%1" in file "%2"
               else display sysmsg(6308,item,fnam)<26> ;*Editing "%1" in file "%2"
            if idcnt gt 1 then crt ' [':id:'/':idcnt:']':
            crt
            if here gt last then here = last
            gosub display.line
         case comd eq 'WM'             ; * word marker display (change)
            if dlim ne '' then wordmark = dlim
            if wordmark eq '"'
               then display sysmsg(6307,"'":wordmark:"'")<17> ;*WordMark is %1
               else display sysmsg(6307,'"':wordmark:'"')<17> ;*WordMark is %1
         case 1 ; gosub bad.command
      end case
      return

x:    begin case
* Another way of quitting
         case comd eq 'X' ; comd = 'QK' ; redo = @true
         case comd eq 'XEQ'               ; * execute a command
            if not(sec.xeq.flg) then
               display sysmsg(6304)<37> ;*XEQ disabled
               comi = ''
               return
            end
            loop
               if rest ne '' then
                  if index(rest,'@',1) then
                     rest = change(rest,'@FILE',trim(dprt:' ':fprt))
                     rest = change(rest,'@file',trim(dprt:' ':fprt))
                     rest = change(rest,'@ID',item)
                     rest = change(rest,'@id',item)
                     rest = change(rest,'@FM',@fm)
                     rest = change(rest,'@fm',@fm)
                     rest = change(rest,'@VM',vm)
                     rest = change(rest,'@vm',vm)
                     rest = change(rest,'@SM',sm)
                     rest = change(rest,'@sm',sm)
                     if index(rest,'@LINE',1) or index(rest,'@line',1) then
                        gosub get.line
                        rest = change(rest,'@LINE',line)
                        rest = change(rest,'@line',line)
                     end
                  end
                  temp = dcount(rest,@fm)
                  for test = 1 to temp
                     execute rest<test>
                  next test
               end
               test = @(0,0)
xeq.command:
               stub = sysmsg(6304)<38> ;*<RETURN> or command :
               if dlim eq '!'
                  then rest = ''
                  else gosub get.rope; rest = rope
               if rest eq '' then
                  crt; display sysmsg(6304)<39>: ;*Returned -
                  display sysmsg(6308,item,fnam)<26> ;*Editing "%1" in file "%2"
               end
            until rest eq '' do
               crt
            repeat
            gosub display.line
         case comd eq 'XTD'               ; * hex to decimal
            crt iconv(rest,'MX')
         case 1 ; gosub bad.command
      end case
      return

y:    begin case
         case comd eq 'Y'or comd eq 'YANK'
            if hold eq '' and idcnt gt 1 then
               display sysmsg(6310)<45> ;* No list held
               return
            end
            if hold<id> eq '' then
               hold<id> = idlist<id>
               display sysmsg(6310,idlist<id>)<46> ;* %1 added to list
            end else
               hold<id> = ''
               display sysmsg(6310,idlist<id>)<47> ;* %1 removed
            end
         case 1 ; gosub bad.command
      end case
      return

z:    begin case
         case comd eq 'Z' or comd eq 'ZOOM'    ; * Page movement
            rest = trim(upcase(rest))
            begin case
               case rest[1,1] eq 'F'
                  pant = span        ; bolt = botl
               case rest[1,1] eq 'H'
                  pant = int(span/2) ; bolt = int(botl/2)
               case pant eq span
                  pant = int(span/2) ; bolt = int(botl/2)
               case 1
                  pant = span       ; bolt = botl
            end case
            display sysmsg(6310,pant,bolt)<50> ;*Page Mode movement <%1>   ^%2v
         case 1 ; gosub bad.command
      end case
      return


set.bounds:
      if numb eq '' then numb = 1
      dawn = here
      if dawn lt 1 then dawn = 1
      dusk = dawn + numb - 1
      if dusk gt last then dusk = last
      numb = 0
      return

null.command:
      if dlim eq '/' then
         comd = 'L'
         if numb eq '' then numb = huge
         if rest[1,1] eq dlim then
            comd = 'LW'
            rest = rest[2,*]
         end
         return
      end
      if dlim eq '-' or dlim eq '+' then
         if rest eq '' then rest = 1
      end
      if dlim eq '!' then
         comd ='XEQ'
         return
      end
      if numb ne '' then comd = numb ; return
      if dlim eq '' and rest eq '' then
* If they press enter, we will work out the + command
         if here lt last then
            begin case
               case stak<1,1> matches "'+'1N0N"
                  stak<1,1> = '+' : (stak<1,1>[2,999] + 1)
               case stak<1,1> matches "'-'1N0N"
                  temp = stak<1,1>[2,999] - 1
                  if temp eq 0
                     then del stak<1,1>
                     else stak<1,1> = '-':temp
               case 1
                  ins "+1" before stak<1,1>
                  del stak<1,staknumb>
            end case
         end
         here += 1
         if here gt last then
            here = 1
* Test for no or one line, short items are still a bitch
            if stak<1,1> ne '1' then
               ins '1' before stak<1,1>
               del stak<1,staknumb>
            end
         end
         gosub display.line
         return
      end
      crt
* Various delimiter dependant commands
      begin case
         case dlim eq '+' and rest matches '1N0N'
            begin case
               case stak<1,1> matches "'+'1N0N"
                  stak<1,1> = '+' : (stak<1,1>[2,999] + rest)
               case stak<1,1> matches "'-'1N0N"
                  temp = stak<1,1>[2,999] - rest
                  begin case
                     case  temp eq 0
                        del stak<1,1>
                     case temp gt 0
                        stak<1,1> = '-':temp
                     case temp lt 0
                        stak<1,1> = '+':abs(temp)
                  end case
               case 1
                  ins dlim:rest before stak<1,1>
                  del stak<1,staknumb>
            end case
            here = here + rest
            if here gt last then here = last
            gosub display.line
         case dlim eq '-' and rest matches '1N0N'
            begin case
               case stak<1,1> matches "'-'1N0N"
                  stak<1,1> = '-' : (stak<1,1>[2,999] + rest)
               case stak<1,1> matches "'+'1N0N"
                  temp = stak<1,1>[2,999] - rest
                  begin case
                     case  temp eq 0
                        del stak<1,1>
                     case temp gt 0
                        stak<1,1> = '+':temp
                     case temp lt 0
                        stak<1,1> = temp
                  end case
               case 1
                  ins dlim:rest before stak<1,1>
                  del stak<1,staknumb>
            end case
            here = here - rest
            if here lt 0 then here = 0
            if here gt last then here = last
            gosub display.line
         case dlim eq '^'
            wild = not(wild)
            if wild
               then display sysmsg(6533) ;*Expansion of non-printing characters enabled
               else display sysmsg(6532) ;*Expansion of non-printing characters disabled
         case dlim eq '='
            display sysmsg(6311)<9> ;*UNIDATA prestore is not implemented - Use "PR"
         case dlim eq '.'
            gosub dot.command
         case dlim eq '$'
            if not(sec.xcom.flg) then
               display sysmsg(6311)<10> ;*$ external commands disabled
               comi = ''
               return
            end
            save = comi ; comi = rest
            gosub parse.command
            comi = save
            if dlim eq '?' then
               execute 'SORT AE_XCOMS LIKE $... WITH F2 LIKE ..._AE F1 FMT "40L" F2'
               return
            end
            comd = '$':comd
            xcom = oconv(comd,'TAE_XCOMS;X;2;2')
            begin case
               case xcom eq ''
                  display sysmsg(6311,comd)<11> ;*Record "%1" does not exist in "AE_XCOMS".
               case xcom[len(xcom)-2,3] ne '_AE'
                  disp = sysmsg(6303,comd,xcom) ;*Line 2 of record "%1" in file "AE_XCOMS"'
                  stub = sysmsg(1750) ;*Press RETURN to continue
                  gosub show.disp
               case not(catalogued(xcom))
                  display sysmsg(6311,xcom)<17> ;*Subroutine %1 not catalogued
               case 1
                  that = this ; savl = here:am:last:am:beg:am:fin:am:krj
                  save = comi:am:comd:am:item:am:fnam
                  comd = comd:' ':rest
                  call @xcom(mat junk)
                  item = save<3>
                  fnam = save<4>
                  if here lt 0 then here = 0
                  gosub set.record
                  if here gt last then here = last
                  comd = ''
                  if comi ne stak<1,1> then
                     stak = insert(stak,1,1,0,comi)
                     stak = delete(stak,1,staknumb,0)
                  end
                  if that ne this then
                     display save<2>:sysmsg(6304)<6> ;* - CHANGES HAVE BEEN MADE
                     oops = that ; oopc = save<1>
                     ooph = savl<1> ; oopb = savl<3> ; oopf = savl<4> ; oopk = field(savl,am,5,3)
                  end
                  that = ''
            end case
         case comi eq '?'
            disp = sysmsg(6307,name,term,whom)<2> ;*         Login name = %1 (%2, userno %3)
            disp<-1> = sysmsg(6307,acct)<3> ;*            Account = %1
            if path ne '' then disp<-1> = sysmsg(6307,path)<4> ;*           VOC path = %1
            disp<-1> = sysmsg(6307,levl)<5> ;*              Level = %1
            disp<-1> = sysmsg(6307,fnam)<6> ;*          File name = %1
            disp<-1> = sysmsg(6307,item)<7> ;*          Record id = %1
            disp<-1> = sysmsg(6307,here)<8> ;*       Current line = %1
            disp<-1> = sysmsg(6307,last)<9> ;*              Lines = %1
            disp<-1> = sysmsg(6307,len(this))<10> ;*         Characters = %1
            if chan ne '' then
               krj1 = chan<1,1>
               disp<-1> = sysmsg(6307,krj1)<11> ;*Last Change command = %1
            end
            if cmat ne '' then
               temp = 'CM':cmat<1,3>:cmat<1,1>:cmat<1,2>
               disp<-1> = sysmsg(6307,temp)<12> ;*Last CMatch command = %1
            end
            if olda then
               temp = 'A':olda<1,2>:olda<1,1>
               disp<-1> = sysmsg(6307,temp)<13> ;*Last Append command = %1
            end
            if beg or fin then
               disp<-1> = sysmsg(6307,beg,fin)<14> ;*              Block = %1-%2
            end
            if comdmark eq '"' then
               temp = "'":comdmark:"'"
            end else temp = '"':comdmark:'"'
            disp<-1> = sysmsg(6307,temp)<15>:', ' ;*Command Delimiter is %1
            if nill eq '"' then
               temp = "'":nill:"'"
            end else temp = '"':nill:'"'
            disp := sysmsg(6307,temp)<16>:', ' ;*character to end inserting is %1
            if wordmark eq '"' then
               temp = "'":wordmark:"'"
            end else temp = '"':wordmark:'"'
            disp := sysmsg(6307,temp)<17> ;*WordMark is %1
            disp<-1> = sysmsg(6307,pwin,plen)<18> ;*Page: window for PA/PL/PP is %1, length for P is %2
            if wild
               then disp<-1> = sysmsg(6533) ;*Expansion of non-printing characters enabled
               else disp<-1> = sysmsg(6532) ;*Expansion of non-printing characters disabled
            vals = sysmsg(6307)<24> ;*CASE
            if caseflag
               then disp<-1> = sysmsg(6307,vals)<19>:', ' ;*%1 flag ON
               else disp<-1> = sysmsg(6307,vals)<20>:', ' ;*%1 flag OFF
            vals = sysmsg(6307)<25> ;*SPACE
            if spaceflag
               then disp := sysmsg(6307,vals)<19>:', ' ;*%1 flag ON
               else disp := sysmsg(6307,vals)<20>:', ' ;*%1 flag OFF
            vals = sysmsg(6307)<26> ;*SHOW
            if shew
               then disp := sysmsg(6307,vals)<19>:', ' ;*%1 flag ON
               else disp := sysmsg(6307,vals)<20>:', ' ;*%1 flag OFF
            vals = sysmsg(6307)<27> ;* BLOCK
            if blockflag
               then disp := sysmsg(6307,vals)<19>:', ' ;*%1 flag ON
               else disp := sysmsg(6307,vals)<20>:', ' ;*%1 flag OFF
            if bell ne ''
               then disp := sysmsg(6307)<28> ;*BELL
               else disp := sysmsg(6307)<29> ;*NO BELL
            if oopc ne ''
               then disp<-1> = sysmsg(6307,oopc)<21> ;*OOPS will restore record prior to command: %1
               else disp<-1> = sysmsg(6307)<22> ;*OOPS already executed, or no changes in effect.
            gosub show.disp
         case comi[1,2] eq '<>' ; gosub botharr
         case comi[1,1] eq '<' ; gosub leftarr
         case comi[1,1] eq '>' ; gosub rightarr
         case dlim eq '\' and rest[1,1] eq '\'    ;* clear the tag pointers
            krj = ''
            display sysmsg(6306)<20> ;*Tags cleared
         case dlim eq '\'      ;* set a tag pointer
            locate(here,krj,2;posn) then
               display sysmsg(6306,here)<23> ;*There is already a Tag on line %1
               return
            end
            if rest eq '' then rest = 'T':here
            rest = trim(upcase(rest))
            locate(rest,krj,1;posn) then
               display sysmsg(6306,rest)<24> ;*There is already a Tag lablled %1
               return
            end
            posn = krj<3>+1
            ins rest before krj<1,posn>
            ins here before krj<2,posn>
            krj<3> = posn
            display sysmsg(6306,rest,here)<19> ;*Setting Tag labelled %1 at %2
         case (dlim eq '[' or dlim eq ']') and (rest[1,1] eq '[' or rest[1,1] eq ']')
            gosub show.tags
         case dlim eq '[' and rest eq ''
            posn = krj<3>-1
            if posn le 0 then posn = dcount(krj<2>,vm)
            if posn gt 0 then
               comd = krj<2,posn>
               krj<3> = posn ; krj1 = krj<1,posn>
               display sysmsg(6306,comd,krj1)<22> ;*Moved to line %1 labelled %2
            end else comd = ''
            if comd eq '' then display sysmsg(6306)<25> ;*No Tag found
         case dlim eq ']' and rest eq ''
            posn = krj<3>+1
            comd = krj<2,posn>
            if comd eq '' then posn = 1 ; comd = krj<2,posn>
            if comd eq '' then
               display sysmsg(6306)<25> ;*No Tag found
            end else
               krj<3> = posn ; krj1 = krj<1,posn>
               display sysmsg(6306,comd,krj1)<22> ;*Moved to line %1 labelled %2
            end
         case dlim eq '[' or dlim eq ']'
            locate(upcase(rest),krj,1;posn) then comd = krj<2,posn> else comd = ''
            if comd ne '' then
               krj<3> = posn ; krj1 = krj<1,posn>
               display sysmsg(6306,comd,krj1)<22> ;*Moved to line %1 labelled %2
               return
            end else display sysmsg(6306)<25> ;*No Tag found
         case dlim eq '|'
            brian = not(brian)
            if brian
               then display sysmsg(6306)<30> ;*Code colouring is ON
               else display sysmsg(6306)<31> ;*Code colouring is OFF
         case dlim eq '{'
            comd = 'ZOOM' ; rest = 'H'
         case dlim eq '}'
            comd = 'ZOOM' ; rest = 'F'
         case 1
            gosub bad.command
      end case
      return

parse.cols:
      good = @true
      cols = field(rest,dlim,2)
      convert ' ,.:' to '----' in cols
      rest = field(rest,dlim,1)
      colf = field(cols,'-',2)
      cols = field(cols,'-',1)
      if colf eq '' then colf = cols
      if cols ne '' then
         if not(cols matches '1N0N') or not(colf matches '1N0N') then
            display sysmsg(6310)<23> ;*Range specifications must be positive whole numbers.
            good = @false
            gosub bad.comd ; return
         end
      end
      if colf lt cols then
         display sysmsg(6310)<24> ;*Ending number # must exceed or equal starting number #.
         good = @false
         gosub bad.comd ; return
      end
      colf = colf - cols + 1
      return

parse.nums:
      temp = rest
      test = oconv(temp,'MC/N')
      convert test to str(' ',len(test)) in temp
      temp = trim(temp)
      rest = field(temp,' ',2)
      temp = field(temp,' ',1)
      begin case
         case numb
            if temp
               then rest = temp
               else rest = here
            return
         case rest and temp
            numb = rest - temp + 1
            rest = temp
            if numb lt 1 then numb = 0
            return
         case temp
            numb = temp
            rest = here
      end case
      return

change.command:
      if comd eq 'RA' then
         if numb eq '' then
            numb = dcount(chan,vm)
            if numb then
               display sysmsg(6308,numb)<28> ;*Last %1 changes
               for xx = numb to 1 step back
                  crt fmt(xx,'R%2'):' ':chan<1,xx>
               next xx
            end else
               display sysmsg(6308)<33> ;* there are no prior changes
            end
            return
         end
         if numb gt channumb or numb lt 1 then
            display sysmsg(6308,channumb)<29> ;*Change must be in range 1-%1.
            comi = ''
            return
         end
         comi = chan<1,numb>
         if comi eq '' then
            display sysmsg(6308,numb)<30> ;*There is no change number %1.
            return
         end
         chan = delete(chan,1,numb,0)
         chan = insert(chan,1,1,0,comi)
         gosub parse.command
         comi = 'RA'
      end
      save = upcase(field(rest,dlim,3,2))
      if save ne '' then rest = rest[1,col1()]
      gosub get.fromto
      temp = save
      if comi eq '' then return
      chng = 0 ; save = here
      glob = index(temp,'G',1)
      show = shew or index(temp,'S',1)
      convert dlim:'GS' to '-' in temp
      rest = dlim:temp
      gosub parse.cols
      if not(good) then return
      if numb lt plen then show = @true
      dnum = 1
      gosub set.bounds
      for here = dawn to dusk
         gosub get.line
         gosub change.line
         gosub check.line
      next here
      here = dusk
      if comi ne '' and upcase(comi) ne 'RA' then
         chan = insert(chan,1,1,0,comi)
         chan = delete(chan,1,channumb,0)
      end
      if chng then
         gosub reset.record
         if not(show) and dnum gt plen then
            display sysmsg(6310,chng,here)<22> ;*%1 lines changed - now at %2
         end
      end
      return

get.format:
      rest = upcase(rest)
      temp = index(rest,'-M',1)
      if temp then fr(1) = field(rest[temp+2,huge],' ',1) ; fr(2) = ''
      if not(fr(1) matches '1N0N') then fr(1) = ''
      if fr(1) eq '' then
         fr(1) = 5
         for xx = 1 to last until xx gt 200
            temp = this<xx>
            temp = len(temp) - len(trimf(temp))
            if temp then fr(1) = temp ; exit
         next xx
      end
      temp = index(rest,'-I',1)
      if temp then fr(2) = field(rest[temp+2,huge],' ',1)
      if not(fr(2) matches '1N0N') then fr(2) = ''
      if fr(2) eq '' then
         fr(2) = int((fr(1)+1)/2)
      end
      if index(rest,'-A',1) then fr(9) = @true else fr(9) = ''
      if index(rest,'-N',1) then fr(10) = @true else fr(10) = ''
      if index(rest,'-C',1) then
         fr(1) = 0
         fr(2) = 1
         fr(9) = @true
         fr(10) = @true
      end
      return

get.fromto:
      if count(rest,dlim) gt 2 then
         display sysmsg(6310)<26> ;*Too many delimiters (3 max.).
         comi = ''
         return
      end
      line = field(rest,dlim,1)
      gosub parse.line
      cfrom = line
      line = field(rest,dlim,2)
      gosub parse.line
      cto = line
      if cto eq '' and count(rest,dlim) lt 2 then
         display sysmsg(6310)<27> ;*Missing required TO field (for "CHANGE/FROM/TO").
         comi = ''
         return
      end
      return

change.line:
      if cols then
         left = line[1,cols-1]
         mine = line[cols,colf]
         rest = line[cols+colf,huge]
      end else
         left = ''
         mine = line
         rest = ''
      end
      if cfrom eq '' then
         mine = cto:mine
      end else
         if glob then
            if caseflag
               then xxno = count(mine,cfrom)
               else xxno = count(upcase(mine),upcase(cfrom))
         end else xxno = 1
         yyno = len(cfrom)
         for xx = xxno to 1 step back
            if caseflag
               then posn = index(mine,cfrom,xx)
               else posn = index(upcase(mine),upcase(cfrom),xx)
            if posn then
               mine = mine[1,(posn-1)]:cto:mine[(posn+yyno),huge]
            end else exit
         next xx
      end
      mine = left:mine:rest
      return

conv.command:
      chng = 0 ; save = here
      show = shew or index(rest,'S',1) or index(rest,'s',1)
      dnum = 1
      if numb lt plen then show = @true
      if numb eq '' and rest matches '1N0N' then numb = rest
      gosub set.bounds
      ctyp = ccom[1,1]
      begin case
* ICONV
         case ctyp eq '*' ; ccom = ccom[2,huge]
* Text conversion LC, TC, or UC command
         case ctyp eq 'Q' ; ccom = ccom[2,huge]
      end case
      for here = dawn to dusk
         gosub get.line
         begin case
            case ctyp eq '*'
               mine = iconv(line,ccom)
            case ctyp eq 'Q'
               mine = field(trim(line),' ',1)
               flag = @false
               if mine ne 'REMOVE' then
                  if mine[1,3] eq 'REM' then flag = @true
                  if mine[1,1] eq '*' then flag = @true
                  if mine[1,1] eq '!' then flag = @true
               end
               if flag then
                  mine = line
               end else
                  xxno = len(line)
                  mine = ''
                  flag = ''
* Have to use substring so text conversion works
                  bite = ''
                  for xx = 1 to xxno
                     bit = line[xx,1]
                     begin case
                        case bit eq flag
                           flag = ''
                           mine := bit
                        case flag ne ''
                           mine := bit
                        case index(qt,bit,1)
                           flag = bit
                           mine := oconv(bite,ccom):bit
                           bite = ''
                        case bit eq ';'
                           test = trim(line[xx+1,huge])[1,1]
                           if test eq '*' or test eq '!' then
                              flag = am
                              mine := oconv(bite,ccom):bit
                              bite = ''
                           end else bite := bit
                        case 1
                           bite := bit
                     end case
                  next xx
                  mine = mine:oconv(bite,ccom)
               end
            case 1
               mine = oconv(line,ccom)
         end case
         if mine eq '' then mine = line
         gosub check.line
      next here
      here = dusk
      if chng then
         gosub reset.record
         if not(show) and dnum gt plen then
            display sysmsg(6310,chng,here)<22> ;*%1 lines changed - now at %2
         end
      end
      return

dot.command:
      if comi eq '.' then comi = '.L1'
      save = comi
      comi = field(comi,dlim,2,huge)
      gosub parse.command
      begin case
         case comd eq 'A'                 ; * append to line
            if numb eq '' then numb = 1
            if numb gt dcount(stak,vm) then
               display sysmsg(6311,numb)<12> ;*History command %1 does not exist.
            end else
               stak<1,numb> := rest
               crt fmt(numb,'R%3'):'. ':stak<1,numb>
            end
         case comd eq 'C'                 ; * change lines
            if numb eq '' then numb = 1
            if numb gt dcount(stak,vm) then
               display sysmsg(6311,numb)<12> ;*History command %1 does not exist.
            end else
               gosub get.fromto
               if comi eq '' then comd = '' ; return
               glob = index(field(rest,dlim,3),'G',1)
               glob = glob + index(field(rest,dlim,3),'g',1)
               line = stak<1,numb>
               cols = '' ; colf = ''
               gosub change.line
               stak<1,numb> = mine
               crt fmt(numb,'R%3'):'. ':mine
            end
         case comd eq 'D'                 ; * delete lines
            if numb eq '' then numb = 1
            if numb gt dcount(stak,vm) then
               display sysmsg(6311,numb)<12> ;*History command %1 does not exist.
            end else
               stak = delete(stak,1,numb,0)
               display sysmsg(6311,numb)<13> ;*History #%1 DELETEd.'
            end
         case comd eq 'I'                 ; * insert a new line
            if numb eq '' then numb = 1
            if numb gt dcount(stak,vm) then
               display sysmsg(6311,numb)<12> ;*History command %1 does not exist.
            end else
               if rest ne '' then
                  stak = insert(stak,1,numb,0,rest)
                  stak = delete(stak,1,staknumb,0)
                  crt fmt(numb,'R%3'):'. ':stak<1,numb>
               end
            end
         case comd eq 'L'                 ; * list lines
            if numb eq '' then numb = plen
            if numb gt dcount(stak,vm) then numb = dcount(stak,vm)
            temp = rem(numb+1,plen)
            for xx = numb to 1 step back
               crt fmt(xx,'R%3'):'. ':stak<1,xx>
               if xx gt 1 and rem(xx,plen) = temp then
                  stub = sysmsg(5042) ;*Press return to continue, Q to quit
                  loop
                     rlen = 1
                     gosub get.rope; crt begn:ceol:
                     wait = trim(upcase(rope))[1,1]
                  until index('Q',wait,1) do repeat
                  rlen = 0
                  if wait eq 'Q' then exit
               end
            next xx
         case comd eq 'R'                 ; * restore a line to latest
            if numb eq '' then numb = 1
            if numb le dcount(stak,vm) then
               temp = stak<1,numb>
               stak = insert(stak,1,1,0,temp)
               stak = delete(stak,1,staknumb,0)
            end
         case comd eq 'S'
            if numb eq '' then numb = 1
            if numb gt presnumb then
               display sysmsg(6311,numb,presnumb)<14> ;*%1 is greater than pre-store limit of %2
               return
            end
            rest = trim(rest)
            dawn = field(rest,dlim,1) ; if dawn eq '' then dawn = 1
            dusk = field(rest,dlim,2) ; if dusk eq '' then dusk = 1
            if not(dawn matches '1N0N' and dusk matches '1N0N') then
               display sysmsg(6311)<15> ;*One of the values was not a number
               return
            end
            if dawn gt dusk then temp = dawn ; dawn = dusk ; dusk = temp
            temp = ''
            for xx = dusk to dawn step back
               temp<1,1,-1> = stak<1,xx>
            next xx
            pres<1,numb> = temp
         case comd eq 'U'                 ; * upcase line
            if numb eq '' then numb = 1
            if numb gt dcount(stak,vm)
               then display sysmsg(6311,numb)<12> ;*History command %1 does not exist.
               else stak<1,numb> = upcase(stak<1,numb>)
         case comd eq 'UL'                ; * downcase line
            if numb eq '' then numb = 1
            if numb gt dcount(stak,vm)
               then display sysmsg(6311,numb)<12> ;*History command %1 does not exist.
               else stak<1,numb> = downcase(stak<1,numb>)
         case comd eq 'UT'                ; * text case line
            if numb eq '' then numb = 1
            if numb gt dcount(stak,vm)
               then display sysmsg(6311,numb)<12> ;*History command %1 does not exist.
               else stak<1,numb> = oconv(stak<1,numb>,'mct')
         case comd eq 'W'                 ; * wiggle case line
            if numb eq '' then numb = 1
            if numb gt dcount(stak,vm) then
               display sysmsg(6311,numb)<12> ;*History command %1 does not exist.
            end else
               cope = stak<1,numb>
               gosub rope.a.dope
               stak<1,numb> = cope
               crt fmt(numb,'R%3'):'. ':cope
            end
         case comd eq 'X'              ; * re-execute an editor command
            if numb eq '' then numb = 1
            if numb gt dcount(stak,vm) then
               display sysmsg(6311,numb)<12> ;*History command %1 does not exist.
            end else
               salt = stak<1,numb>
               stak = delete(stak,1,numb,0)
            end
         case 1
            comi = save
            gosub bad.command
      end case
      comi = '' ; comd = ''
      return

viewonly:
      display sysmsg(6305,bell)<7> ;*That command is not allowed in VIEW mode%1
      comi = ''
      return

bad.command:
      if comi ne oconv(comi,'mcp') then
         display sysmsg(6507) ;*Command contains non-printing characters
         return
      end
      display sysmsg(6305)<8> ;*Command not understood - try "H" for help.
bad.comd:
      xxno = len(comi)
      temp = ''
      for xx = 1 to xxno
         bite = comi[xx,1]
         bite = seq(bite)
         if bite ge 127 or bite lt 32 then
            bite = '^':fmt(bite,'R%3')
         end else bite = char(bite)
         temp = temp:bite
      next xx
      display sysmsg(6305,temp)<9> ;*Command was: "%1"
      temp = ''
      comi = ''
      return

save.stuff:
      if not(sec.unload.flg) then
         display sysmsg(6304)<30> ;*Unload disabled
         comi = ''
         return
      end
      keepquot = @false
      gosub parse.rest
      odpt = '' ; ofpt = bite<1> ; oipt = bite<2>
      onam = ofpt
      if ofpt eq 'DICT' then
         odpt = ofpt ; ofpt = oipt ; oipt = bite<3>
         onam = onam:' ':ofpt
      end
      if oipt eq '' then
         if odpt ne '' then
            display sysmsg(6304)<31> ;*Cannot save to null item.
            gosub bad.comd ; return
         end
         oipt = ofpt ; odpt = dprt ; ofpt = fprt ; onam = fnam
      end
      if dprt eq odpt and fprt eq ofpt then
         ofil = file
      end else
         open odpt, ofpt to ofil else
            display sysmsg(1427,'"':odpt:' ':ofpt:'"') ;*Cannot open %1
            gosub bad.comd ; return
         end
      end
      if prepflag then
         sec.call2.type = 2
         sec.fn2 = ofpt
         sec.id2 = oipt
         sec.dict2.flg = (odpt = 'DICT')
         call @prepprog(mat security)
         if sec.stop.flg then stop
         if not(sec.ok2.flg) then
            gosub bad.comd ; return
         end
      end
      if source.control then
         dict.flag = odpt
         file.name = ofpt
         record.name = oipt
         record.data = this
         caller = '3'
         write.allowed = '1'
         updated = '0'
         call source.control(dict.flag,file.name,
                             record.name,record.data,caller,write.allowed,updated)
         if write.allowed ne '1' then
            display sysmsg(6304)<32> ;*WRITE NOT ALLOWED
            return
         end
      end
      readv test from ofil, oipt, 1 then
         if comd ne 'PASTE' then
            read test from ofil, oipt then
               if test eq this then
                  display sysmsg(3247)
                  test =''
                  return
               end
            end
         end
         stub = sysmsg(6521) ;*Record already exists. Overwrite (y/n)?
         gosub get.answ
         if answ ne yes then return
      end
      if comd eq 'PASTE'
         then write kept(bnum) on ofil, oipt on error gosub writerr ; return
         else write this on ofil, oipt on error gosub writerr ; return
      display sysmsg(6308,oipt,onam)<16> ;*Record "%1" saved in "%2".
      return

write.record:
      if rest ne '' then
         if comd eq 'FD' then
            display sysmsg(6310)<28> ;*"FD" operates only on the current record & file.
         end else
            display sysmsg(6310)<29> ;*"FI" only for current record & file. Use SAVE.
         end
         gosub bad.comd ; return
      end
      if source.control then
         dict.flag = dprt
         file.name = fprt
         record.name = item
         if comd eq 'FD' then record.data = '' else record.data = this
         caller = '3'
         write.allowed = '1'
         updated = '0'
         call source.control(dict.flag,file.name,
                             record.name,record.data,caller,write.allowed,updated)
         if write.allowed ne '1' then
            display sysmsg(6304)<32> ;*WRITE NOT ALLOWED
            return
         end
      end
      if not(lock) then
         display sysmsg(6310)<30> ;*Record lock has been released!   Write not allowed.
         comi = ''
         return
      end
      if comd eq 'FD' then
         stub = sysmsg(6310,ny)<31> ;****** You are about to DELETE the record! OK? %1
         gosub get.answ
         if answ ne yes then return

         delete file, item on error gosub writerr ; return

         display sysmsg(6310,item,fnam)<32> ;*Deleted "%1" from file "%2".
      end else
         if comd eq 'SV' then

            if dprt and orig ne this and listindex('A,C,I,S',',',upcase(this[1,1]))
               then this = trim(field(this,am,1,14),am,'T')
            writeu this on file, item on error gosub writerr ; return

            orig = this ; oops = '' ; oopc = '' ; ooph = ''
            oopb = '' ; oopf = '' ; oopk = ''
            display sysmsg(6310,item,fnam,here)<33> ;*Saved "%1" in "%2" - now at line %3.
            return
         end else

            if dprt and orig ne this and listindex('A,C,I,S',',',upcase(this[1,1]))
               then this = trim(field(this,am,1,14),am,'T')
            write this on file, item on error gosub writerr ; return

            if orig eq this then
               display sysmsg(6310,item,fnam)<34> ;*Filed "%1" in file "%2" UNCHANGED.
            end else display sysmsg(6310,item,fnam)<35> ;*Filed "%1" in file "%2".
            oops = '' ; oopc = '' ; ooph = '' ; * ewd
         end
      end
      stopsign = @true
      if index(comd,'B',1) then
         temp = 'BASIC'
         if index(comd,'D',1) then temp<2> = ' DEBUGGING'
         gosub exec.that
      end
      if index(comd,'C',1) then
         temp = 'CATALOG'
         begin case
            case index(comd,'L',1) ; temp<2> = ' LOCAL'
*          case index(comd,'G',1) ; temp<2> = ' GLOBAL'
         end case
         gosub exec.that
      end
      if index(comd,'R',1) then temp = 'RUN' ; gosub exec.that
      return

edit.fields:
      if here lt 1 then here = 1
      gosub get.line ; mine = line
      convert vmrk to am in line
      ttid = whom:'_':levl:'_':vals:'.in.line#':here

      write line on acom, ttid on error gosub writerr ; return

      display sysmsg(6306,view,vals)<11>: ;*%1ing %2 as fields...
      execute verb:' AE_COMS ':ttid:options
      test = @(0,0)
      display sysmsg(6306,view,item,fnam)<12> ;*Back %1ing the record "%2" in file "%3"
      read line from acom, ttid else line = ''
      delete acom, ttid
      return

reset.fields:
      convert am to vmrk in line
      if '*':mine ne '*':line then
         gosub savethat
         memr(cell)<lnum> = line
         gosub reset.record
      end
      return

load.item:
      if not(sec.load.flg) then
         display sysmsg(6304)<23> ;*LOAD disabled
         comi = ''
         return
      end
      gosub get.load
      if temp eq '' then return
      if prepflag then
         sec.call2.type = 1
         sec.fn2 = ofpt
         sec.id2 = oipt
         sec.dict2.flg = (odpt = 'DICT')
         call @prepprog(mat security)
         if sec.stop.flg then stop
         if not(sec.ok2.flg) then
            if mode<1> ne 'PAGE' then gosub bad.comd
            return
         end
      end
      if comd[len(comd),1] ne 'A' then
         gosub get.lines
         if not(temp) then return
      end
      if mode<1> ne 'PAGE' then gosub savethat
      this = insert(this,here+1,0,0,temp)
      temp = dcount(temp,am)
      if mode<1> ne 'PAGE' then here = here + temp
      display sysmsg(6310,here,temp)<11> ;*At line %1, %2 lines loaded.
      temp = ''
      gosub set.record
      return

get.load:
      temp = ''
      if trim(rest) eq '' then
         stub = sysmsg(6310)<36> ;*Record name, or file name and record name >
         gosub get.rope; rest = rope; crt
         if trim(rest) eq '' then temp = ''; return
      end
      keepquot = @false
      gosub parse.rest
      onam = bite<1>
      onid = bite<2>
      if onam eq 'DICT' then
         onam = onam:' ':onid
         onid = bite<3>
         if onid eq '' then onid = item
      end
      if onid eq '' then onid = onam ; onam = ''
      if onid eq '' then return
      if onam eq '' then
         onam = fnam
         odpt = dprt
         ofpt = fprt
         ofil = file
      end else
         odpt = field(onam,' ',1)
         ofpt = field(onam,' ',2)
         if ofpt eq '' then ofpt = odpt ; odpt = ''
         open odpt, ofpt to ofil else
            display sysmsg(1427,onam) ;*Cannot open %1 ;*Cannot open %1
            gosub bad.comd ; return
         end
      end
      read temp from ofil, onid else
         if dcount(bite,am) eq 1 then
            open onid to ofil then
               read temp from ofil, item then return
            end
         end
         display sysmsg(6310,onid,onam)<38> ;*Record "%1" was not found on file "%2".
         if mode<1> ne 'PAGE' then gosub bad.comd
      end
      return

changematch.command:
      patt = field(rest,dlim,1)
      if not(caseflag) then patt = upcase(patt)
$ifndef qm
      gosub parse.pattern
      if not(good) then
         display sysmsg(6313,bit)<2> ;*Pattern: character "%1" is not allowed unless quoted.
         comi = ''
         return
      end
$endif
      if comd eq 'CM' then cmat = dlim:vm:rest:vm:numb
      cto = field(rest,dlim,3,huge)
      line = cto ; gosub parse.line ; cto = line
      cfrom = upcase(field(rest,dlim,2))
      if cfrom eq '' then cfrom = 'L'
      if cfrom eq 'L' then mmat = dlim:vm:rest
      if numb eq '' and cto eq '' and (cfrom eq 'L' or cfrom eq 'N') then
         numb = last
         flag = @true
      end else flag = @false
      BEGIN CASE
         CASE cfrom matches '"I"0N'
            cols = oconv(cfrom,'MCN')
            colf = cols
            cfrom = 'I'
         CASE cfrom matches '0N"I"'
            cols = oconv(cfrom,'MCN') + 1
            colf = cols
            cfrom = 'I'
         CASE len(cfrom) eq 1 and index('ADLNPR+-*/',cfrom,1)
         CASE 1
            gosub parse.cols
            if not(good) then return
            cfrom = ''
            colf = cols + colf - 1
      END CASE
cm.del.entry:
      gosub set.bounds
      if flag then dawn += 1
      show = shew ; dnum = 1
      chng = 0 ; save = here ; dnum = 2
      test = ''
      for here = dawn to dusk
         gosub get.line
         if caseflag then
            if cfrom eq 'DE'
               then good = index(line,patt,1)
               else good = (line matches patt)
         end else
            if cfrom eq 'DE'
               then good = index(upcase(line),patt,1)
               else good = (upcase(line) matches patt)
         end
         if not(good) then
            if cfrom eq 'N' then
               numb += 1
               if show or numb lt plen then gosub display.line
               if flag then dusk = here
            end
            continue
         end
         numb += 1
         mine = line
         begin case
            case cfrom eq 'A'
               mine = line:cto
            case cfrom[1,1] eq 'D'
               if show or numb lt plen then crt fmt((here + chng),lfmt):'+ ':line
               test<-1> = here
            case cfrom eq 'L'
               gosub display.line
               if flag then dusk = here
            case cfrom eq 'P'
               mine = cto:line
            case cfrom eq 'R'
               mine = cto
            case cfrom eq 'N'
               numb -= 1
            case cfrom eq '+' and num(line) and num(cto)
               mine = line + cto
            case cfrom eq '-' and num(line) and num(cto)
               mine = line - cto
            case cfrom eq '*' and num(line) and num(cto)
               mine = line * cto
            case cfrom eq '/' and num(line) and num(cto) and cto
               mine = line / cto
            case 1
               gosub parse.mine
         end case
         if not(index('DL',cfrom,1)) or cfrom eq '' then
            gosub check.line
         end
      next here
      if cfrom[1,1] eq 'D' and numb then
         gosub savethis
         for here = numb to 1 step back
            temp = test<here>
            cell = int((temp-1)/cellsize) + 1
            coff = rem(temp,cellsize)
            if coff eq 0 then coff = cellsize
            del memr(cell)<coff>

            if beg eq temp then beg = 0
            if beg gt temp then beg -= 1
            if fin eq temp then fin = 0
            if fin gt temp then fin -= 1
            for xx = dcount(krj<1>,vm) to 1 step back
               begin case
                  case krj<2,xx> gt temp ; krj<2,xx> -= 1
                  case krj<2,xx> eq temp
                     del krj<1,xx> ; del krj<2,xx> ; krj<3> -= 1
               end case
            next xx
         next here
         test = ''
         gosub reset.record
         here = dusk - numb
      end else
         here = dusk
      end
      if dawn ne dusk then
         if here lt last
            then display sysmsg(6313,here)<3> ;*At line %1.
            else display sysmsg(6313,here)<4> ;*Bottom at %1.
      end
      if not(numb) then
         if cfrom eq 'N' then
            display sysmsg(6313,dawn,dusk,patt)<5>: ;*No lines (in %1-%2) NOT matching pattern "%3"
         end else display sysmsg(6313,dawn,dusk,patt)<6>: ;*No lines (in %1-%2) matching pattern "%3"
      end else
         begin case
            case cfrom[1,1] eq 'D'
               display sysmsg(6313,numb,patt)<7>: ;*Deleted %1 lines matching "%2"
            case cfrom eq 'L'
               display sysmsg(6313,numb,patt)<8>: ;*Found %1 lines matching "%2"
            case cfrom eq 'N'
               display sysmsg(6313,numb,patt)<9>: ;*Found %1 lines NOT matching "%2"
         end case
      end

      if chng then
         gosub reset.record
         begin case
            case dawn eq dusk
               return
            case cfrom eq 'A'
               display sysmsg(6313,cto)<10>: ;*"%1" appended to
            case cfrom[1,1] eq 'D'
               display sysmsg(6313)<11>: ;*Deleted
            case cfrom eq 'P'
               display sysmsg(6313,cto)<12>: ;*"%1" prefixed to
            case cfrom eq 'R'
               display sysmsg(6313,cto)<13>: ;*Replaced with "%",
                           case cfrom eq 'L' or cfrom eq 'N'
            case cfrom eq '+'
               display sysmsg(6313,cto)<33>: ;*%1 added to
            case cfrom eq '-'
               display sysmsg(6313,cto)<34>: ;*%1 taken from
            case cfrom eq '*'
               display sysmsg(6313,cto)<35>: ;*line multiplied by %1 in
            case cfrom eq '/'
               display sysmsg(6313,cto)<36>: ;*line divided by %1 in
            case cols eq colf
               display sysmsg(6313,cols,cto)<14>: ;*Element %1 changed to "%2" in
            case cols
               display sysmsg(6313,cols,colf,cto)<15>: ;*Element %1-%2 changed to "%3" in
         end case
         if chng eq 1
            then display sysmsg(6313,patt)<16> ;*1 line matching "%1"
            else display sysmsg(6313,chng,patt)<17> ;*%1 lines matching "%2"
      end
      return

$ifndef qm
parse.pattern:
* bits<1> are the pattern pieces
*     <2> quote or 'p'attern flag
*     <3> partial patterns
      cntr = 1
      bits = ''
      flag = ''
      good = @true
      first = @true
      xxno = len(patt)
      gosub quote.pattern
      for xx = 1 to xxno
         bit = patt[xx,1]
         begin case
            case bit eq flag
               flag = ''
               first = @true
               cntr = cntr + 1
            case flag ne ''
               bits<1,cntr> = bits<1,cntr>:bit
            case index(qt,bit,1)
               bits<2,cntr> = bit
               flag = bit
            case first
               if not(bit matches '1n') then
                  good = @false
                  return
               end
               first = @false
               bits<2,cntr> = 'p'
               bits<1,cntr> = bits<1,cntr>:bit
               if bit = '0' then bits<3,cntr> = patt[xx+2,xxno]
            case 1
               if not(index('AaNnXx',bit,1)) then
                  good = @false
                  return
               end
               bits<1,cntr> = bits<1,cntr>:oconv(bit,'mcu')
               first = @true
               cntr = cntr + 1
         end case
      next xx
      cntr = cntr - 1
      return


quote.pattern:
* Adds quotes to the pattern if required
* If they use any quotes at all, we don't do a thing
      if index(patt,'"',1) then return
      if index(patt,'\',1) then return
      if index(patt,"'",1) then return
      xx = 1
      temp = ''
      test = ''
      loop
         left = patt[xx,2]:'*'
         if index(digits,left[1,1],1) and index('AaNnXx',left[2,1],1) then
            if test ne '' then temp := "'":test:"'"
            temp := patt[xx,2]
            test = ''
            xx += 1
         end else test := patt[xx,1]
      until xx gt xxno do
         xx += 1
      repeat
      patt = temp
      if test ne '' then patt := "'":test:"'"
      if index(patt,"'",1) then crt '>':comd:dlim:patt:dlim:field(rest,dlim,2,999)
      return
$endif

parse.mine:
$ifdef qm
      mine = parse(line,patt,am)
$else
      mine = ''
      posn = 1
      xxno = len(line)
      for xx = 1 to cntr
         what = bits<1,xx>
         type = bits<2,xx>
         nmbr = what[1,1]
         begin case
            case xx gt colf
               mine<xx> = line[posn,xxno]
               xx = cntr
            case type ne 'p'
               mine<xx> = line[posn,len(what)]
               posn = posn + len(what)
            case xx = cntr
               mine<xx> = line[posn,xxno]
            case nmbr eq '0'
* look to match the rest of the line with the partial pattern
               test = bits<3,xx>
               yy = posn
               bit = ''
               loop
               until yy gt xxno do
                  chit = line[yy,xxno]
               until chit matches test do
                  bit := chit[1,1]
                  yy += 1
               repeat
               posn += len(bit)
               mine<xx> = bit
            case 1
               bit = line[posn,nmbr]
               posn += len(bit)
               mine<xx> = bit
         end case
      next xx
$endif
      if cfrom eq 'I' then
         ins cto before mine<cols>
      end else
         mine<cols> = cto
         for xx = cols+1 to colf
            mine = delete(mine,cols+1)
         next xx
      end
      convert am to '' in mine
      return

get.lines:
      stub = sysmsg(6313)<20> ;*'Q'uit, or starting line >
      pick = 1
      gosub get.rope; dawn = rope
      dawn = upcase(trim(dawn))
      if dawn eq '' then dawn = 'Q'
      if dawn[1,1] eq 'Q' then temp = @false ; crt ; return
      if not(dawn matches '1N0N') then
         crt
         display sysmsg(6309)<6> ;*Nothing done - starting and ending lines must be numeric.
         gosub bad.comd ; return
      end
      if dawn gt dcount(temp,am) then
         crt
         display sysmsg(6309)<2> ;*Nothing done - record does not have that many lines.
         gosub bad.comd ; return
      end
      stub = stub:dawn:' ':sysmsg(6313)<21> ;*, ending line >
      pick = dcount(temp,am)
      gosub get.rope; dusk = rope
      dusk = upcase(trim(dusk))
      if dusk eq '' then dusk = 'Q'
      if dusk[1,1] eq 'Q' then temp = @false ; crt ; return
      if not(dusk matches '1N0N') then
         crt
         display sysmsg(6309)<6> ;*Nothing done - starting and ending lines must be numeric.
         gosub bad.comd ; return
      end
      if dusk gt dcount(temp,am) then
         dusk = dcount(temp,am)
         display begn:sysmsg(6313,onam,dawn,dusk)<22>: ;*File is %1: 'Q'uit, or starting line > %2, %3
      end
      temp = field(temp,am,dawn,dusk-dawn+1)
      crt
      return

show.tags:
      if krj<3> eq ''
         then disp = sysmsg(6306)<25> ;*No Tag found
         else disp = sysmsg(6306)<21> ;*Tags at line-Labelled
      posn = krj<3>
      xxno = dcount(krj<1>,vm)
      for xx = 1 to xxno
         disp<-1> = krj<2,xx> 'r#12'
         if xx eq posn then disp := '>' else disp := ' '
         disp := krj<1,xx>
      next xx
      convert badc to gudc in disp
      gosub show.disp
      return

parse.bite:
      mine = ''
      loop
      while bite ne '' do
         bite = trimf(bite)
         xx = fold
         if count(bite[1,xx],' ') and trim(bite[xx+1,1]) ne '' then
            loop
            until trim(bite[xx,1]) eq '' do
               xx -=1
            repeat
            mine<-1> = bite[1,xx-1]
         end else
            mine<-1> = bite[1,xx]
         end
         bite = bite[xx+1,len(bite)]
      repeat
      return

show.help:
      crt
      if help eq '' then
         help = sysmsg(6300,verb,view) ;* %1 version 3.01
      end
      rest = trim(upcase(rest))
      if rest eq am then
         hard = @true
         rest = ''
      end else hard = @false
      disp = ''
      stub = ''
      if rest eq '' then flag = @true else flag = @false
      if rest eq 'NEW' then disp = sysmsg(6313)<23>:am ;*New Features
      good = @false
      xxno = dcount(help,am)
      for xx = 1 to xxno
         temp = help<xx>
         bite = temp[1,len(rest)]
         bit = temp[14,1]
         if index('-+=#',bit,1)
            then temp = temp[1,13]:'-':temp[15,huge]
            else bit = ''

         if bit ne '' then
            flag = @false
            if bit eq '#' and rest eq 'NEW'               then flag = @true
            if (bit eq '#' or bit eq '+') and rest eq ''  then flag = @true
            if not(viewflag) then
               if bit eq '=' and rest eq 'NEW'            then flag = @true
               if bit eq '=' or bit eq '-' and rest eq '' then flag = @true
            end
         end
         if not(flag) and rest ne '' and bite eq rest then
            if bit eq '#' or bit eq '+' then flag = @true
            if not(viewflag) then
               if bit eq '=' or bit eq '-' then flag = @true
            end
         end
         if flag then
            disp<-1> = temp
            good = @true
         end
      next xx

      if not(good) then
         disp := am
         disp<-1> = sysmsg(6313,rest)<25> ;*No explanation of '%1' is available.
         disp<-1> = sysmsg(6313)<26> ;*For a list of words that have explanations, type 'HELP'.
         disp := am
      end
      if hard then gosub print.disp else gosub show.disp
      return

show.disp:
      if stub eq '' then stub = sysmsg(6313)<24> ;*Press return to continue showing this, Q to quit
      xxno = dcount(disp,am)
      pg = 0
      for xx = 1 to xxno
         pg += 1
         if pg ge system(3) then
            loop
               rlen = 1
               gosub get.rope; answ = rope
               crt begn:ceol:
               answ = trim(upcase(answ))[1,1]
            until index('QTPN-',answ,1) do repeat
            rlen = 0
            if answ eq 'Q' then return
            if answ eq 'T' then xx = 1
            if answ eq '-' or answ eq 'P' then
               xx -= 2*(system(3)-1)
               if xx lt 1 then xx = 1
            end
            pg = 1
         end
         crt disp<xx>
      next xx
      disp = ''
      return

print.disp:
      printer on
      heading upcase(verb):" help file    ":timedate():"'LL'"
      xxno = dcount(disp,am)
      for xx = 1 to xxno
         print disp<xx>
      next xx
      printer close
      return

spool.item:
      save = here
      head = sysmsg(6308,item,fnam,acct)<21> ;*Record - %1 File - %2 Account - %3
      head = head:timedate():"'LL'"
      temp = span
      printer on
      temp = temp - llen - 2
      heading head
      for here = dawn to dusk
         gosub get.line
         convert badc to gudc in line
         print fmt(here,lfmt):': ':line[1,temp]
         loop
            line = line[temp+1,len(line)]
         until line eq '' do
            print space(llen+2):line[1,temp]
         repeat
      next here
      printer close
      here = save
      return

get.page.comd:
      gosub get.keyc
      pulp = seq(keyc)
      begin case
         case cpos eq uarr ;* up key
            if here le 1 then crt bell:; return
            gosub check.page
            here -= 1
            if prow le 1 then
               ptop = ptop - bolt
               if ptop lt 1 then ptop = 1
               gosub disp.page
            end
            gosub get.line; mine = line
         case cpos eq darr ;* down key
            if here gt last then crt bell:; return
            gosub check.page
            here += 1
            if prow ge botl then
               ptop = ptop + bolt
               if ptop gt last then ptop = last - botl + 2
               if ptop le 1 then ptop = 1
               gosub disp.page
            end
            gosub get.line; mine = line
         case cpos eq larr ;* left key
            if pchr le 1 then crt bell:; return
            pchr -= 1
            if pchr lt ppos then
               gosub check.page
               gosub disp.page
            end
         case cpos eq rarr ;* right key
            pchr += 1
            if pchr-ppos ge span then
               gosub check.page
               gosub disp.page
            end
         case cpos eq ftab ;* tab key
            test = mine
            dirn = 1
            gosub seek.word
            if posn then
               pchr = test
               if pchr-ppos ge span then
                  gosub check.page
                  gosub disp.page
               end
               return
            end
            if here ge last then crt bell:; return
            gosub check.page
            here += 1
            gosub get.line; mine = line
            test = line
            convert xchars to xchart in test
            test = trim(test)[1,1]
            if test eq ''
               then pchr = 1
               else pchr = index(mine,test,1)
            temp = @false
            if pchr lt ppos then temp = @true
            if pchr-ppos ge span then temp = @true
            if prow ge botl then
               ptop = ptop + botl
               if ptop ge last then ptop = last - botl + 2
               if ptop le 1 then ptop = 1
               temp = @true
            end
            if temp then gosub disp.page
         case cpos eq btab ;* backtab key
            if pchr le 1 and here le 1
               then crt bell; ; return
            test = mine
            dirn = -1
            gosub seek.word
            if posn gt 0 then
               pchr = test
               if pchr lt ppos then
                  gosub check.page
                  gosub disp.page
               end
               return
            end
            if here le 1 then crt bell:; return
            here -= 1
            gosub get.line; mine = line
            test = line:'  ' ; pchr = len(test)
            gosub seek.word
            temp = @false
            if posn
               then pchr = test
               else pchr = 1
            if pchr lt ppos then temp = @true
            if pchr-ppos ge span then temp = @true
            if prow le 1 then
               ptop = ptop - botl
               if ptop lt 1 then ptop = 1
               if ptop le 1 then ptop = 1
               temp = @true
            end
            if temp then gosub disp.page
         case cpos eq upag ;* page up key
            gosub check.page
            ptop -= botl
            if ptop lt 1 then ptop = 1
            here -= botl
            if here lt 1 then here = 1
            pchr = 1
            gosub get.line; mine = line
            gosub disp.page
         case cpos eq dpag ;* page down key
            gosub check.page
            ptop = ptop + botl
            if ptop gt last then ptop = last - botl + 2
            here = here + botl
            if here gt last then here = last
            pchr = 1
            gosub get.line; mine = line
            gosub disp.page
         case cpos eq lpag ;* start of line key
            pchr = 1
            if pchr lt ppos then gosub check.page; gosub disp.page
         case cpos eq rpag ;* end of line key
            pchr = len(mine)+1
            if pchr lt ppos then gosub check.page; gosub disp.page
            if pchr-ppos ge span then
               gosub check.page
               gosub disp.page
            end
         case cpos eq tpag ;* top page key
            gosub check.page
            here = 1
            ptop = 1
            pchr = 1
            gosub disp.page
            gosub get.line; mine = line
         case cpos eq bpag ;* bottom page key
            gosub check.page
            here = last
            ptop = last - botl + 2
            if ptop lt 1 then ptop = 1
            gosub get.line
            pchr = len(line)+1
            gosub disp.page
            gosub get.line; mine = line
         case cpos eq escp or pulp eq 139 ;* escape key or F12
            if that eq '' and this eq am and '*':mine eq '*':line then this = ''
            if this ne that or '*':mine ne '*':line then
               if blockflag then
                  stub = sysmsg(6312)<30> ;* Are you SURE you want to abandon your changes?
                  rlen = 1
                  stay = pchr
                  gosub get.bott
                  rlen = 0
                  answ = upcase(rope)
                  pchr = stay
                  if answ ne yes then
                     display bott:revb:sysmsg(6308)<27>:revf: ;*Press <F1> for help.
                     return
                  end
               end
               display @(0,botl):ceol:revb:sysmsg(6304)<43>:revf ;*ABANDONING CHANGES
            end
            this = that
            here = site
            gosub set.record
            mode = 'LINE'
            if mouser ne '' then crt mouse.off
         case cpos eq phlp ;* help key
            gosub check.page
            gosub page.help
         case cpos eq zoom ;* Go to line key
            gosub zoot
            gosub disp.page
            gosub get.line; mine = line
         case cpos eq skey ;* forward search
            gosub change.last
            gosub forward.search
         case cpos eq rkey ;* reverse search
            gosub change.last
            gosub reverse.search
         case cpos eq xkey
            stay = pchr
            if not(sec.xeq.flg) then
               stub =  sysmsg(6304)<37>:' - ':sysmsg(1750) ;*XEQ disabled - press RETURN to continue
               gosub get.bott
               pcol = stay<1,1>
               display bott:revb:sysmsg(6308)<27>:revf: ;*Press <F1> for help.
               pchr = stay<1>
               crt @(pcol,prow):
               return
            end
            crt bott:
            rest = ''
            dlim = ''
            gosub xeq.command
            gosub disp.page
            pchr = stay<1>
            crt @(pcol,prow):
         case not(sec.write.flg)
            crt bell:
         case cpos eq delc ;* delete character key
            if mine eq '' then return
            if pchr eq 1 then
               mine = mine[2,len(mine)]
            end else
               mine = mine[1,pchr-1]:mine[pchr+1,len(mine)]
            end
            temp = mine[pchr,span-pcol]
            convert badc to gudc in temp
            crt @(pcol,prow):ceol:temp:
         case cpos eq dell ;* delete line key
            del this<here>
            gosub set.record
            gosub disp.page
            gosub get.line; mine = line
         case cpos eq delr ;* delete to end of line key
            begin case
* if at end of line or there is nothing else on line, move next line up
               case pchr gt len(mine) or trimf(mine[pchr,huge]) eq ''
                  if here ge last then crt bell:; return
                  line = fmt(mine,'l#':pchr-1):this<here+1>
                  del this<here>
                  this<here> = line
                  gosub set.record
                  gosub disp.page
                  gosub get.line; mine = line
* if on a space, remove spaces
               case mine[pchr,1] eq ' '
                  line = fmt(mine,'l#':pchr-1):trimf(mine[pchr,huge])
                  this<here> = line
                  gosub set.record
                  gosub disp.page
                  mine = line
* otherwise, delete rest of line
               case 1
                  mine = mine[1,pchr-1]
                  this<here> = mine
                  memr(cell)<lnum> = mine
                  line = mine
                  crt @(pcol,prow):ceol:
            end case
         case cpos eq bspc ;* backspace key
            if pchr eq 1 then crt bell:; return
            pchr -= 1
            mine = mine[1,pchr-1]:mine[pchr+1,len(mine)]
            if pchr lt ppos then
               gosub check.page
               gosub disp.page
            end else
               pcol = pchr-ppos
               crt @(pcol,prow):ceol:
               temp = mine[pchr,span-pcol]
               convert badc to gudc in temp
               crt temp:
            end
         case cpos eq carr ;* carriage return key
            if pchr eq 1 then
               line = ''
            end else
               line = mine[1,pchr-1]
               mine = mine[pchr,len(mine)]
            end
            if here gt last then
               last += 1
               lnum += 1
               gosub insert.line
            end else
               memr(cell)<lnum> = line
               last += 1
               lnum += 1
               line = mine
               gosub insert.line
               mine = ''
            end
            gosub reset.record
            here += 1
            pchr = 1
            if prow ge botl then
               ptop = ptop + botl
               if ptop ge last then ptop = last - botl + 1
               if ptop le 1 then ptop = 1
               gosub display.page
            end else gosub disp.page
            if here le last then
               gosub get.line
               mine = line
            end else
               temp = mine[1,span]
               convert badc to gudc in temp
               crt @(0,prow+1):temp:
            end
         case cpos eq wkey ;* change word case
            mope = mine ; gosub hardcase ; mine = mope
            gosub check.page
            gosub get.line ; mine = line
            gosub disp.page
         case cpos eq togg ;* toggle mode key
            if mode<2> eq 'Ins' then
               mode<2> = 'Rep'
            end else mode<2> = 'Ins'
         case cpos eq writ ;* write away data key
            gosub check.page
            mode = 'LINE'
            if mouser ne '' then crt mouse.off
         case cpos eq menu
            gosub alacarte
         case cpos eq mous ;* mouse button pressed
            if mrow eq '' then return
            gosub check.page
            begin case
               case mrow lt 1
                  gosub alacarte
               case mrow gt botl
                  gosub page.help
               case (ptop+mrow-1) gt last
                  null
               case 1
                  here = ptop+mrow-1
                  gosub get.line ; mine = line
                  pcol = mcol ; prow = mrow
                  pchr = ppos + pcol
            end case
            gosub disp.page
         case pulp ne 252 and pulp ne 253 and (pulp lt 28 or pulp gt 127 or len(keyc) gt 1)
            crt bell:
         case pulp eq 30 or pulp eq 31
            crt bell:
         case 1
            if pulp eq 28 then keyc = char(252)
            if pulp eq 29 then keyc = char(253)
            if pchr and len(mine) lt (pchr-1) then
               mine = mine:str(' ',pchr)
               mine = mine[1,pchr-1]
            end
            if mode<2> eq 'Ins'
               then offset = pchr
               else offset = pchr+1
            if pchr eq 1
               then mine = keyc:mine[offset,len(mine)]
               else mine = mine[1,pchr-1]:keyc:mine[offset,len(mine)]
            if mode<2> eq 'Ins' then
               crt @(pcol,prow):ceol:
               temp = mine[pchr,span-pcol]
            end else temp = keyc
            convert badc to gudc in temp
            crt @(pcol,prow):temp:
            pchr += 1
            if pchr-ppos ge span then
               gosub check.page
               gosub disp.page
            end
      end case
      return

seek.word:
*     dirn:  1 = fore; -1 = back
      convert xchars to xchart in test
      maxi = dcount(test,' ')
      posn = dcount(test[1,pchr],' ')
      loop
         posn += dirn
         if posn gt maxi then posn = 0
      until posn lt 1 do
         temp = field(test,' ',posn)
      until temp ne '' do repeat
      test = col1()+1
      return

change.last:
      rest= lastfind
      gosub input.rest
      lastfind = rest
      return

input.rest:
      stub = sysmsg(6654):'> ' ;*Search:
      stay = pchr
      pick = rest; gosub get.bott; rest = rope
      pchr = stay
      display bott:revb:sysmsg(6308)<27>:revf: ;*Press <F1> for help.
      return

forward.search:
      if lastfind eq '' then return
      temp = lastfind
* is it in this line or the rest of the item?
      if caseflag then
         test = index(mine[pchr+1,huge],temp,1)
      end else
         temp = upcase(temp)
         test = index(upcase(mine[pchr+1,huge]),temp,1)
      end
      save = here
      gosub check.page
      if test then
         test += pchr
      end else
         dawn = here+1
         dusk = last
         for here = dawn to dusk until test
            gosub get.line
            if not(caseflag) then line = upcase(line)
            test = index(line,temp,1)
            if test then save = here
         next here
      end
      if test then
         if save lt ptop or save ge (ptop+botl) then ptop = save
         here = save
         pchr = test
         gosub disp.page
      end else here = save
      gosub get.line; mine = line
      return

reverse.search:
      if lastfind eq '' then return
      temp = lastfind
* is it in this line before the cursor position or the rest of the item above?
      if caseflag then
         what = count(mine[1,pchr-1],temp)
         test = index(mine[1,pchr-1],temp,what)
      end else
         temp = upcase(temp)
         what = count(upcase(mine[1,pchr-1]),temp)
         test = index(upcase(mine[1,pchr-1]),temp,what)
      end
      save = here
      gosub check.page
      if not(test) then
         dawn = 1
         dusk = here-1
         for here = dusk to dawn step back until test
            gosub get.line
            if not(caseflag) then line = upcase(line)
            what = count(line,temp)
            if what then
               test = index(line,temp,what)
               save = here
            end
         next here
      end
      if test then
         if save lt ptop or save ge (ptop+botl) then ptop = save
         here = save
         pchr = test
         gosub disp.page
      end else here = save
      gosub get.line; mine = line
      return

zoot:
      stub = sysmsg(6313)<27> ;*Go to line :
      stay = pchr
      gosub get.bott; numb = trim(rope)
      pchr = stay
      display bott:revb:sysmsg(6308)<27>:revf: ;*Press <F1> for help.
      if not(numb matches '1N0N') then numb = here
      if numb lt 1 then numb = 1
      if numb gt last then numb = last
      if numb eq here then return
      gosub check.page
      here = numb
      ptop = here
      pchr = 1
      return

find.labels:
      if not(caseflag) then rest = upcase(rest)
      if index(comd,'A',1) then
         bump = -1
         dawn = here - 1
         if dawn lt 1 then return
         if numb then dusk = here - numb else dusk = 1
         if dusk lt 1 then dusk = 1
      end else
         bump = 1
         dawn = here + 1
         if dawn gt last then dawn = 1
         if numb then dusk = here + numb else dusk = last
         if dusk gt last then dusk = last
      end
      for here = dawn to dusk step bump
         gosub get.line
         linr = line
         gosub get.label
         if not(caseflag) then labl = upcase(labl)
         if labl ne '' then
            if rest eq '' or labl matches rest then
               gosub display.line
               if not(numb) then return
            end
         end
      next here
      return

find.matches:
      gosub get.line
* Get rid of any label
      linr = line
      gosub get.label
      if labl ne ''
         then thisline = change(line,flab,str(' ',len(flab)),1,1)
         else thisline = line
      flab = ''
      temp = field(thisline,' ',1)  ;* ??
* Get the first word on the line
      word = field(trim(upcase(thisline)),' ',1)
      begin case
         case rest ne ''
            seek = upcase(rest)
         case word[1,1] eq '*' or word[1,1] eq '!'
            seek = word[1,1]
         case 1
            locate(word,fm.words;posn) then
               if index(comd,'A' ,1)
                  then seek = fm.finda<posn>
                  else seek = fm.findf<posn>
            end else
               locate(word,endwords,1;posn) then
                  seek = 'END'
               end else
                  display sysmsg(6310,word)<3> ;*Starting word "%1" unknown
                  gosub bad.comd ; return
               end
            end
      end case
      if seek eq '' then
         display sysmsg(6310,word,comd)<4> ;*%1 has no matching word for %2
         gosub bad.comd ; return
      end
      posn = index(upcase(thisline),word,1)
      xxno = dcount(seek,vm)
      for xx = 1 to xxno
         seek<1,xx> = space(posn-1):seek<1,xx>
      next xx
      if index(comd,'A',1) then
         bump = -1
         dawn = here - 1
         if dawn lt 1 then return
         dusk = 1
      end else
         bump = 1
         dawn = here + 1
         if dawn gt last then return
         dusk = last
      end
      save = here
      for here = dawn to dusk step bump
         gosub get.line
         line = upcase(line)

         linr = line
         gosub get.label
         if labl then line = change(line,upcase(flab),str(' ',len(flab)),1,1)

         for xx = 1 to xxno
            slen = len(seek<1,xx>)
            if line[1,slen] eq seek<1,xx> then
               if trim(line[slen+1,1]) eq '' then
                  gosub display.line
                  return
               end
            end
         next xx
      next here
      here = save
      gosub get.line
      return

get.label:
      test = trimf(linr)
      labl = field(test,' ',1)
      test = trim(trimf(test[col2(),9999])[1,2])
      chit = labl[1,1]
      begin case
         case chit matches '1N' or chit eq '.'
            labl = field(labl,'*',1)
            labl = field(labl,'!',1)
            flab = labl
            labl = field(labl,':',1)
            test = convert('.':digits,'',labl)
            if test ne '' then labl = ''
         case chit matches '1A' and (index(labl,':',1) or (test[1,1] eq ':' and test ne ':='))
            flab = field(linr,':',1):':'
            labl = field(labl,':',1)
            test = oconv(oconv(labl,'MC/A'),'MC/N')
            test = convert('._%$','',test)
            if test ne '' then labl = ''
         case 1
            labl = ''
      end case
      return

check.page:
      if '*':mine ne '*':line then
         if here gt last then lnum += 1; last += 1
         memr(cell)<lnum> = mine
         gosub reset.record
      end
      return

page.help:
      gosub clear.page
      if pagehelp eq '' then
         if sec.write.flg then
            pagehelp = sysmsg(6302) ;* Page editing help
         end else
            pagehelp = sysmsg(6301) ;* Page viewing help
         end
      end
      disp = pagehelp ; stub = ''
* little wrinkle for different backtabs
      if system(91)
         then disp = change(disp,'BackTab','Ctrl-Tab')
         else disp = change(disp,'BackTab','Shift-Tab')
      gosub show.disp
      stub = sysmsg(1750) ;*Press RETURN to continue
      gosub get.bott
      gosub display.page
      return

get.line:
      line = ''
      if here eq 0 then
         cell = 1
         lnum = 0
         return
      end
      if here gt last then return
      cell = int((here-1)/cellsize) + 1
      lnum = rem(here,cellsize)
      if lnum eq 0 then lnum = cellsize
      line = memr(cell)<lnum>
!* Remove trailing carriage return so UNIX and Windows can intermingle
!      line = trim(line,char(13),'B')
      return

delete.lines:
      chng = 0
      if dawn gt dusk then
         display sysmsg(6313,dawn,dusk)<28> ;*No deletion possible - %1 > %2.
         return
      end
      gosub savethat
      chng = dusk - dawn + 1
      begin case
         case dawn le 1 and dusk ge last
            krj = ''
            this = ''
            beg = 0
            fin = 0
         case dusk ge last
            temp = index(this,am,dawn-1)
            this = this[1,temp-1]
            if beg gt dawn then beg = 0
            if fin gt dawn then fin = 0
            for xx = dcount(krj<1>,vm) to 1 step back
               if krj<2,xx> gt dawn then
                  del krj<1,xx> ; del krj<2,xx> ; krj<3> -= 1
               end
            next xx
         case dawn eq 1
            temp = index(this,am,dusk)
            this = this[temp+1,len(this)]
            if beg le dusk then beg = 0 else beg = beg - chng
            if fin le dusk then fin = 0 else fin = fin - chng
            for xx = dcount(krj<1>,vm) to 1 step back
               if krj<2,xx> le dusk then
                  del krj<1,xx> ; del krj<2,xx> ; krj<3> -= 1
               end
            next xx
         case 1
            temp = index(this,am,dawn-1)
            temp<2> = index(this,am,dusk)
            this = this[1,temp<1>]:this[temp<2>+1,len(this)]
            if beg ge dawn and beg le dusk then beg = 0 else
               if beg gt dusk then beg -= chng
            end
            if fin ge dawn and fin le dusk then fin = 0 else
               if fin gt dusk then fin -= chng
            end
            for xx = dcount(krj<1>,vm) to 1 step back
               begin case
                  case krj<2,xx> gt dusk ; krj<2,xx> -= chng
                  case krj<2,xx> ge dawn
                     del krj<1,xx> ; del krj<2,xx> ; krj<3> -= 1
               end case
            next xx
      end case
      begin case
         case here gt dusk
            here = here - dusk + dawn - 1
         case here gt dawn
            here = dawn
      end case
      gosub set.record
      return

check.line:
      if '*':mine ne '*':line then
         if not(chng) then gosub savethis
         chng += 1
         memr(cell)<lnum> = mine
         if shew or dnum lt plen then gosub display.line
      end
      return

insert.line:
      if here le beg then beg += 1
      if here le fin then fin += 1
      yyno = dcount(krj<1>,vm)
      for yy = 1 to yyno
         if krj<2,yy> gt here then krj<2,yy> += 1
      next yy
      memr(cell) = insert(memr(cell),lnum,0,0,line)
      if lfmt and len(last) gt 3 and len(last) ne llen then gosub get.lfmt
      return

display.line:
      begin case
         case last eq 0
            here = 0
            gosub get.line
            display begn:sysmsg(6313)<29> ;*Top of empty record.
         case here eq 0
            gosub get.line
            display sysmsg(6313)<30> ;*Top.
         case here gt last
            display sysmsg(6313)<31> ;*Bottom.
         case 1
            gosub get.line
            if wild then
               xxno = len(line)
               temp = ''
               for xx = 1 to xxno
                  bite = line[xx,1]
                  bite = seq(bite)
                  if bite ge 127 or bite lt 32 then
                     bite = '^':fmt(bite,'R%3')
                  end else bite = char(bite)
                  temp = temp:bite
               next xx
               line = temp
            end else convert badc to gudc in line
            crt begn:ceol:
            if lfmt then
               blk = ': '
               if macn then blk ='m'
               if here eq beg then blk = '< '
               if here eq fin then blk = '> '
               if here eq beg and here eq fin then blk = '<>'
               if lfmt then crt (here lfmt):blk:
            end
            if brian then
               if here ge beg and here le fin then
                  showline = hi.selecton:line:hi.selectoff
               end else
                  linr = line
                  offset = 1
                  width = len(line)
                  gosub colour.line
                  showline = lins
               end
               crt showline:ceol
            end else
               crt line
            end
*           crt line ; dnum += 1
            dnum += 1
            if here eq last then display sysmsg(6313,last)<32> ;*Bottom at line %1.
      end case
      return

clear.page:
      for xx = system(3)-1 to 0 step back
         crt @(00,xx):ceol:
      next xx
      return

display.page:
* scroll existing page up
      crt clpg
disp.page:
      if pchr lt 1 then pchr = 1
      gosub clear.page
      gosub get.lfmt
      display bott:revb:sysmsg(6308)<27>:revf: ;*Press <F1> for help.
      crt @(0,0):ceol:revb:
      if viewflag
         then display sysmsg(6308,item,fnam)<25>:ceol: ;*Viewing "%1" in file "%2"
         else display sysmsg(6308,item,fnam)<26>:ceol: ;*Editing "%1" in file "%2"
      crt revf:
      if idcnt gt 1 then crt ' <':id:'/':idcnt:'> ':
      crt
      loop
         begin case
            case pchr lt span
               ppos = 1
               exit
            case pchr lt ppos
               ppos -= pant
            case pchr-ppos ge span
               ppos += pant
            case 1
               exit
         end case
      repeat
      save = here:am:lnum:am:cell:am:line
      for xx = 1 to botl
         here = ptop + xx - 1
         gosub get.line
         if brian then
            disp = line
            convert badc to gudc in disp
            if here ge beg and here le fin then
               newdisp = hi.selecton:disp[ppos,span]:hi.selectoff
            end else
               linr = disp; offset = ppos; width = span
               gosub colour.line
               newdisp = lins
            end
            disp = newdisp
         end else
            disp = line[ppos,span]
            convert badc to gudc in disp
         end
         crt @(0,xx):disp:
      next xx
      here = save<1>; lnum = save<2>; cell = save<3>; line = save<4>
      return

savethis:
      oops = this ; oopc = comi ; ooph = save
      oopb = beg ; oopf = fin ; oopk = krj
      return
savethat:
      oops = this ; oopc = comi ; ooph = here
      oopb = beg ; oopf = fin ; oopk = krj
      return

reset.record:
      matbuild this from memr using am
set.record:
      gosub parse.record
      gosub get.line
      if len(last) gt 3 and len(last) ne llen then gosub get.lfmt
      return

parse.record:
      this = this
      last = dcount(this,am)
      if last eq 0 then
         dim memr(1)
         mat memr = ''
         cell = 1 ; lnum = 0
         return
      end
      numcells = int((last-1)/cellsize)+1
      dim memr(numcells)
      mat memr = ''
$ifdef qm
      for cell = 1 to numcells
         memr(cell) = removef(this,am,cellsize)
      next cell
$else
      cell = 1
      lnum = 0
      line = ''
      loop
         remove bite from this setting mark
         line = line:bite
         begin case
            case mark eq 0
               if line ne '' then
                  line = line[1,len(line)]
               end
               memr(cell) = line
            case mark eq 2
               lnum += 1
               if lnum ge cellsize then
                  memr(cell) = line
                  line = ''
                  cell += 1
                  lnum = 0
               end else
                  line = line:char(256-mark)
               end
            case 1
               line = line:char(256-mark)
         end case
      while mark do
      repeat
$endif
      cell = 1
      lnum = 0
      return

locked.record:
      stub = sysmsg(6310,ny)<39> ;*Record is currently locked by another user. Try again? %1
      gosub get.rope; answ = rope
      answ = upcase(trim(answ))
      if answ eq 'PASSWORD' then
         lock = @false
         read this from file, item then goto carry.on
      end
      if answ[1,1] eq yes then goto edit.item
      return

exec.that:
      temp = temp<1>:' ':fnam:' ':item:temp<2>
      if fileinfo(file,3) ne '4' then
         display sysmsg(6310,temp)<40> ;*Cannot %1 - must be type 1 or 19
         return
      end
      execute temp
      test = @(0,0)
      return

parse.rest:
      bite = ''
      flag = ''
      posn = 1
      xxno = len(rest)
      for xx = 1 to xxno
         bit = rest[xx,1]
         if flag eq '' then
            if bit eq ' ' then
               if bite<posn> ne '' then posn += 1
            end else
               if index(qt,bit,1) then
                  flag = bit
                  if keepquot then bite<posn> = bite<posn>:bit
               end else
                  if bit eq '(' then
                     flag = ')'
                     if bite<posn> ne '' then posn += 1
                     bite<posn> = '('
                  end else bite<posn> = bite<posn>:bit
               end
            end
         end else
            if bit ne flag then
               bite<posn> = bite<posn>:bit
            end else
               if keepquot or bit eq ')' then bite<posn> = bite<posn>:bit
               posn += 1
               flag = ''
            end
         end
      next xx
      return

split.itype:
      bite = ''
      flag = ''
      posn = 1
      xxno = len(line)
      for xx = 1 to xxno
         bit = line[xx,1]
         if flag eq '' then
            if bit eq ';' then
               posn += 1
            end else
               if index(qt,bit,1) then flag = bit
               if bit eq '(' then flag = ')'
               bite<posn> = bite<posn>:bit
            end
         end else
            if bit eq flag[1,1] then flag = flag[2,huge]
            if bit eq '(' and flag[1,1] eq ')' then flag := ')'
            bite<posn> = bite<posn>:bit
         end
      next xx
      return

get.lfmt:
* set up the line format
      llen = len(last)
      if llen lt 3 then llen = 3
      lfmt = 'R%':llen
      if editpage
         then prmt = '*':str('-',llen-1)
         else prmt = str('-',llen)
      return

leftarr:
      numb = oconv(trim(comi[2,len(comi)]),'MCN')
      if numb eq '' then numb = here
      if numb gt last then numb = ''
      if numb ge 0 then
         display sysmsg(6312,numb)<11>: ;*Block starts at line %1
         beg = numb
         if fin and beg gt fin then
            display sysmsg(6312,fin,beg)<12> ;*; End moved from %1 to %2
            fin = beg
            mov = 1
         end else
            if fin then mov = fin - beg + 1 else mov = last - beg
            display sysmsg(6312,mov)<13> ;* (%1 lines)
         end
         if numb eq here then gosub display.line
      end else display sysmsg(6312,numb)<14> ;*Cannot mark line %1
      return

rightarr:
      numb = oconv(trim(comi[2,len(comi)]),'MCN')
      if numb eq '' then numb = here
      if numb gt last then numb = ''
      if numb ge 0 then
         display sysmsg(6312,numb)<15>: ;*Block ends at line %1
         fin = numb
         if beg gt fin then
            display sysmsg(6312,beg,fin)<16> ;*; Start moved from %1 to %2
            beg = fin
            mov = 1
         end else
            if beg then mov = fin - beg + 1 else mov = fin
            display sysmsg(6312,mov)<13> ;* (%1 lines)
         end
         if numb eq here then gosub display.line
      end else display sysmsg(6312,numb)<14> ;*Cannot mark line %1
      return

botharr:
      numb = trim(comi[3,len(comi)])
      begin case
         case numb matches '1N0N'
            numb = numb:am:numb
         case numb matches '1N0N"-"1N0N'
            numb = field(numb,'-',1):am:field(numb,'-',2)
         case numb matches '1N0N" "1N0N'
            numb = field(numb,' ',1):am:field(numb,' ',2)
         case numb eq ''
            numb = here:am:here
         case 1
            numb = ''
      end case
      if numb<2> gt last then numb<2> = last
      if numb<1> gt last then numb = ''
      if numb<2> lt numb<1> then
         display sysmsg(6312,numb<1>,numb<2>)<18>:' => ': ;*Block starts at %1 and ends at %2
         numb = ''
      end
      if numb ne '' then
         beg = numb<1>
         fin = numb<2>
         if beg eq fin then
            display sysmsg(6312,beg)<17> ;*Block starts and ends at line %1
         end else
            display sysmsg(6312,beg,fin)<18> ;*Block starts at %1 and ends at %2
         end
         if here eq beg or here eq fin then
            gosub display.line
         end
      end else display sysmsg(6312)<19> ;*Cannot mark Block
      return

recalc.posn:
      begin case
         case posn lt rest and posn le ooph
         case posn lt rest and posn gt ooph
            posn += numb
         case posn ge rest and posn lt (rest+numb)
            posn += (here+1-rest)
         case posn ge (rest+numb) and posn le ooph
            posn -= numb
      end case
      return

get.answ:
      loop
         rlen = 1
         gosub get.rope
         answ = upcase(trim(rope)[1,1])
      until answ eq yes or answ eq no do
         display sysmsg(6602)  ;* Please answer Y or N
      repeat
      rlen = 0
      crt
      return

writerr:
      if status() eq ER$TRIGGER then
         display sysmsg(3007, @trigger.return.code) ;*Data validation error: %1
      end else
         display sysmsg(6598, status()) ;*Write error %1 (o/s error %2) - Data not saved. Original data will be lost if you leave the editor now.
      end
      return

indenter:
      marg = fr(1) ;* the margin
      dent = fr(2) ;* the indentation
      supp = fr(6) ;* flag - suppress '!' output
      astx = not(fr(9)) ;* flag - keep '*' comments on page edge
      suit = not(fr(10)) ;* flag - indent 'CASE' statements
      dead = 'ADGHIJKMPQSVXYZ'
      push = 'LOOPýWHILEýUNTILýFORýTHENýELSEýBEGINýLOCKEDýON~ERRORýTRYýCATCH'
      pull = 'UNTILýWHILEýREPEATýNEXTýENDýCATCH'
      skip = \';:" (\
      marx = '\"':char(39)
      bang = @false
      hail = 0
      xxno = dcount(this,am)
      dim part(100)
      matparse part from this, am
      this = ''
      bite = ''
      first = @true
* For every line, done in 100 line chunks
      for xx = 1 to xxno
         there = rem(xx,100)
* Done 100, slap it on the end and extract another 100
         if not(there) then
            if first then this = bite else this = this:am:bite
            first = @false
            bite = ''
            thisline = part(100)
            temp = part(0)
            matparse part from temp, am
            if not(supp) then bang = @true; crt '!':
         end else thisline = part(there)
!* Remove trailing carriage return so UNIX and Windows can intermingle
!         thisline = trim(thisline,char(13),'B')

* Check for empty line
         if trim(thisline) eq '' then
            if first then bite<there> = '' else bite<there+1> = ''
            continue
         end

* Set up for a new line
         note = @false
         wcnt = 0; more = 0; less = 0
         mark = ''; tags = ''; lastword = ''
         zz = 1

         thisline = trimf(thisline)
         thatline = upcase(thisline)
         thatline = change(thatline, 'ON ERROR', 'ON~ERROR')

         linr = thisline
         gosub get.label
         if labl ne '' then
            tags = trim(labl)
            thisline = trimf(thisline[len(labl)+1,len(thisline)])
            thatline = trimf(thatline[len(labl)+1,len(thatline)])
* Got raw label, alphabetic ones need colon moved from rest of line
            if tags[1,1] matches '1A' then
               tags := ':'
               thisline = trimf(thisline[2,len(thisline)])
               thatline = trimf(thatline[2,len(thatline)])
            end
         end

         zzno = len(thisline)
         loop
         while zz lt zzno and not(note) do
            loop
               thisun = thatline[zz,1]
               begin case
                  case mark eq '' and index(marx,thisun,1)
                     mark = thisun
                  case mark ne ''
                     if thisun eq mark then mark = ''
                  case wcnt and thisun eq ';'
                     what = field(trim(thatline[zz+1,zzno]),' ',1)
                     if what[1,3] eq 'REM' then what = ''
                     if what[1,1] eq '*' then what = ''
                     if what[1,1] eq '!' then what = ''
                     if what eq '' then zz = zzno
                  case wcnt
                  case thisun eq '!' or thisun eq '$'
                     note = @true; zz = zzno
                  case thisun eq '*'
                     if astx then note = @true
                     zz = zzno
                  case field(thatline,' ',1) eq 'REM'
                     note = @true; zz = zzno
               end case
            while (index(skip,thisun,1) or mark) and zz lt zzno do
               zz += 1
            repeat

            left = zz
            loop
               thisun = thatline[zz,1]
            until index(skip,thisun,1) or zz gt zzno do
               zz += 1
            repeat
            word = thatline[left,zz-left]
            wcnt += 1

* fix for PUBLIC FUNCTION NEXT from INDEX.CLS - SHEESH
            if lastword eq 'SUBROUTINE' or lastword eq 'FUNCTION' then word = ' '

* fixes FOR-NEXT complexities
            if wcnt ne 1 then
               if word eq 'WHILE' or word eq 'UNTIL' then word = ' '
               if word eq 'NEXT' or word eq 'REPEAT' then
                  word = ' '
                  more -= dent
               end
            end

            if wcnt eq 2 then
               if lastword eq 'LOCAL' or lastword eq 'PUBLIC' then
                  if word eq 'SUBROUTINE' or word eq 'FUNCTION'
                     then more += dent
               end
            end

            if word eq 'CASE' then
               if lastword ne 'BEGIN' and lastword ne 'END' then
                  more += dent
                  less += dent
               end
               if suit and lastword eq 'BEGIN' then more += dent
               if suit and lastword eq 'END' then less += dent
            end

            if not(index(dead,word[1,1],1)) then
               locate(word,pull,1;rubbish) then less += dent
               test = word ne 'THEN' & word ne 'ELSE' & word ne 'ON~ERROR' & word ne 'LOCKED'
               what = trim(thisline[zz,zzno])
               if what[1,1] eq ';' then
                  what = trim(what[2,zzno])[1,3]
                  if what[1,3] eq 'REM' then what = ''
                  if what[1,1] eq '*' then what = ''
                  if what[1,1] eq '!' then what = ''
               end
               if test or what eq '' then
                  locate(word,push,1;rubbish) then more += dent
               end
               if not(test) and what ne '' and lastword = '' then
                  more -= dent
                  less -= dent
               end

            end
            lastword = word
         repeat

* marg reduced by less for this line and increased by more after this line
         marg -= less
         if tags eq '' then pict = '' else pict = 'L#':(len(tags)+1)
         if marg+hail gt len(tags) then pict = 'L#':marg+hail
         if thisline eq '!' or thisline eq '$' then note = @true
         if thatline eq 'REM' then note = @true
         if astx and thisline eq '*' then note = @true
         if note then
            if tags eq '' then pict = '' else pict = 'L#':(len(tags)+1)
         end
         thisline = trimb(fmt(tags,pict):thisline)
         if trim(lastword)[1] eq ',' then
            if dent then
               brak = index(thisline,'(',1)
               if brak then
                  hail = brak - marg
               end else hail = 5
               if hail lt 1 then hail = 5
            end
         end else hail = 0
         if first
            then bite<there> = thisline
            else bite<there+1> = thisline
         marg += more
      next xx
      if bang then crt
      if bite ne '' then
         if first then this = bite else this = this:am:bite
      end
      what = ''
      return

get.bott:
      crt bott:
get.rope:
* If the terminal doesn't support screen addressing, do simple input
      if not(editpage) then
         crt begn:stub:
         if rlen then
            input rope,rlen:
            rlen = 0
         end else input rope:
         return
      end
*
* The following variables are used
*
*    BARE - what you are going to reveal (the displayed part)
*    CRAM - insert mode on (vs overwrite mode)
*    PCOL - display position
*    STEM - the prefix part of the display line
*    ICON - a picture of what you last displayed
*    PANS - the PAN increment
*    PPOS - the PAN origin
*    WIDE - the PAN width
*    PULP - SEQ(COMI) - what you get from a key press
*    PURE - untouched, a virgin
*    POSN - the stack position
*    PCHR - text position

      pans = int(span/2)
      posn = 0
      rope = pick; pick = ''

      loop
         if heap then
            stem = prmt:': '
            if posn then stem = '*':fmt(posn, "3'0'R"):stem[5,huge]
         end else stem = '*':stub
         wide = span - len(stem) - 1
         pans = int(wide/2)
         ppos = 1
         pchr = 1
         cram = @true
         icon = space(span)
         crt begn : ceol :
         pure = @true
         if heap then
            if editends then
               pchr = len(rope)+1
               pure = @false
            end
            if editover then cram = @false
            if not(editaint) then pure = @false
            if not(pure) then
               if cram
                  then stem = '>':stem[2,huge]
                  else stem = '#':stem[2,huge]
            end
         end

         loop

            begin case

               case pchr lt ppos
                  loop while pchr lt ppos ; ppos -= pans ; repeat
               case pchr ge (ppos+wide)
                  loop while pchr ge(ppos+wide) ; ppos += pans ; repeat
            end case

            bare = stem : rope[ppos, wide]
            pcol = 0
            if icon ne bare then
               yyno = 0
               for yy = 1 to span until yyno
                  if bare[yy,1] ne icon[yy,1] then yyno = yy
               next yy
               crt @(yyno-1):bare[yyno,span-yyno]:ceol:@(pcol):
               icon = bare[1,span]
            end

            pcol = len(stem) + pchr - ppos
            crt @(pcol) :

            gosub get.keyc
            if cpos eq mous then
               continue
            end

            pulp = seq(keyc)
            if pulp lt 32 or pulp gt 128 then keyc = ''
            if pure then
               if cpos eq 0 and keyc ne '' then
                  rope = ''
                  pchr = 1
               end
               crt @(0):
               if cram then crt '>': else crt '#':
               crt @(pcol):
               pure = @false
            end

            begin case

               case heap and (cpos eq uarr or cpos eq upag)
                  if posn lt dcount(stak, vm) then
                     posn += 1
                     rope = stak<1,posn>
                     if editshow then crt
                  end
                  exit

               case heap and (cpos eq darr or cpos eq dpag)
                  if posn gt 1 then
                     posn -= 1
                     rope = stak<1,posn>
                  end else
                     posn = 0
                     rope = ''
                  end
                  exit

               case heap and cpos eq skey
                  if rope eq '' then
                     if look<1> eq '' then continue
                     comi = look<1,1>
                     gosub parse.command
                     rope = 'L':dlim:rest
                  end else rope = 'L/':rope
                  if rope eq look<1> then rope = 'L'
                  return

               case heap and cpos eq rkey
                  if rope eq '' then
                     if look<1> eq '' then continue
                     comi = look<1,1>
                     gosub parse.command
                     rope = 'LA':dlim:rest
                  end else rope = 'LA/':rope
                  if rope eq look<1> then rope = 'L'
                  rlen = 0
                  return

               case heap and cpos eq writ and pulp ne 23
                  rope = 'PE'
                  rlen = 0
                  return

               case heap and cpos eq phlp
                  stub = '' ; heap = @false ; rest = ''
                  gosub show.help
                  rope = 'D'
                  rlen = 0
                  return

               case cpos eq larr
                  if pchr gt 1 then pchr -= 1

               case cpos eq rarr
                  if pchr le len(rope) then pchr += 1

               case cpos eq lpag
                  pchr = 1

               case cpos eq rpag
                  pchr = len(rope) + 1

               case cpos eq escp or cpos eq zoom
                  posn = 0
                  rope = ''
                  exit

               case cpos eq delc
                  rope = rope[1, pchr-1] : rope[pchr+1, huge]

               case cpos eq delr
                  rope = rope[1, pchr-1]

               case cpos eq bspc
                  if pchr gt 1 then
                     pchr -= 1
                     rope = rope[1, pchr-1] : rope[pchr+1, huge]
                  end

               case cpos eq carr
                  if heap then
                     crt begn : ceol : ':' : rope:
                     if posn then
                        if rope eq stak<1,posn> then del stak<1,posn>
                     end
                  end
                  rlen = 0
                  return

               case cpos eq togg
                  cram = not(cram)
                  crt @(0):
                  if cram then crt '>': else crt '#':
                  crt @(pcol):

               case cpos eq wkey         ;* ctrl-w
                  mope = rope
                  gosub hardcase
                  rope = mope

** User-defined functions f5-f12 (132-139)
               case pulp ge 132 and pulp le 139 and rope eq '' and ukey<1,pulp-131> ne ''
                  rope = ukey<1,pulp-131>
                  crt begn : ceol : ':' : rope:
                  return
**
               case pulp ge 32 and pulp lt 128
                  if cram then
                     rope = rope[1, pchr-1] : keyc : rope[pchr, huge]
                  end else
                     if pchr le len(rope)
                        then rope[pchr, 1] = keyc
                        else rope := keyc
                  end
                  pchr += 1

               case 1
                  crt bell:
            end case
            if rlen and len(rope) ge rlen then
               crt keyc:
               rlen = 0
               return
            end
         repeat
      repeat
      rlen = 0
      return

get.keyc:
$ifdef qm
      keyc = keycode()
$else
* Code for this is at pickwki.com
      gosub get.key(keyc)
$endif
      locate(keyc,keys;cpos) then cpos = acts<cpos> else cpos = 0
      if cpos eq mous then gosub get.mouse
      return

* read in the colours to use
set.colours:
      mat colours = ''
      normal = @false
      read temp from voc, '$AE.COLOURS.':upcase(@term.type):'.':upcase(@logname) else
         read temp from voc, '$AE.COLORS.':upcase(@term.type):'.':upcase(@logname) else
            read temp from voc, '$AE.COLOURS.':upcase(@term.type) else
               read temp from voc, '$AE.COLORS.':upcase(@term.type) else
                  read temp from voc, '$AE.COLOURS.':upcase(@logname) else
                     read temp from voc, '$AE.COLORS.':upcase(@logname) else
                        read temp from voc, '$AE.COLOURS' else
                           read temp from voc, '$AE.COLORS' else temp = ''
                        end
                     end
                  end
               end
            end
         end
      end
      if temp eq '' then return

      line = upcase(trim(remove(temp,dlim)))
      if line[1,1] eq 'X' then
         loop
            line = upcase(trim(remove(temp,dlim)))
            convert ' ' to am in line
            word = line<1>[1,1]
            begin case
               case word eq 'N' ; * NORMAL
                  gosub get.colour
                  if colour ne '' then normal = @true
                  hi.commentoff = colour
                  hi.labeloff   = colour
                  hi.selectoff  = colour
                  hi.stringoff  = colour
                  hi.keyoff     = colour
                  hi.opoff      = colour
                  hi.funcoff    = colour
                  hi.diroff     = colour
                  hi.docoff     = colour
               case word eq 'C' ; gosub get.colour; hi.commenton = colour ; * COMMENT
               case word eq 'L' ; gosub get.colour; hi.labelon = colour   ; * LABEL
               case word eq 'S' ; gosub get.colour; hi.selecton = colour  ; * SELECT
               case word eq 'Q' ; gosub get.colour; hi.stringon = colour  ; * QUOTED
               case word eq 'K' ; gosub get.colour; hi.keyon = colour     ; * KEYWORD
               case word eq 'O' ; gosub get.colour; hi.opon = colour      ; * OPERATOR
               case word eq 'F' ; gosub get.colour; hi.funcon = colour    ; * FUNCTION
               case word eq 'D' ; gosub get.colour; hi.diron = colour     ; * DIRECTIVE
               case word eq 'A' ; gosub get.colour; hi.docon = colour     ; * ATCOMMENT
               case word eq 'B'
                  bite = line<2>
                  if bite matches '1N0N' then biggest = bite+0 else
                     test = bite[1]
                     bite = bite[1,len(bite)-1]
                     if bite matches '1N0N' and (test eq 'P' or test eq 'W')
                        then biggest = (bite+0)*span
                  end
            end case
         while dlim repeat
      end

* clear any unused colours
      for xx = 1 to 9
         if colours(xx,1) eq '' then colours(xx,2) = ''
      next xx
      if not(normal) then mat colours = ''
      return

get.colour:
      bite = line<2>
      forg = upcase(field(bite,',',1))
      bakg = field(bite,',',2)
      colour = ''
      begin case
         case forg matches '1n0n' and bakg matches '1n0n'
            colour = @(-37,forg):@(-38,bakg)
         case forg eq '' ; null
         case 1
            bit = ''
            if index(forg,'-R',1) then colour := revf ; bit := 'R'
            if index(forg,'-F',1) then colour := flaf ; bit := 'F'
            if index(forg,'-U',1) then colour := undf ; bit := 'U'
            if index(forg,'-B',1) then colour := bolf ; bit := 'B'
            if index(forg,'R',1) and not(index(bit,'R',1)) then colour := revb
            if index(forg,'F',1) and not(index(bit,'F',1)) then colour := flab
            if index(forg,'U',1) and not(index(bit,'U',1)) then colour := undb
            if index(forg,'B',1) and not(index(bit,'B',1)) then colour := bolb
      end case
      return

alacarte:
      gosub check.page
      stay = pchr
      what = convert('~',am,sysmsg(6316)<2>) ;* Top menu
      choice = what<1>
      if mouser then
         what<-1> = sysmsg(6316)<10> ;* ^ = Toggle mouse input
         choice[1] = '^'
      end
      gosub f10.menu
      begin case
         case test eq 2
            what = convert('~',am,sysmsg(6316)<3>) ;* File menu
            choice = what<1> ; gosub f10.menu
            begin case
               case test eq 2 ;* Delete
                  x$cc = 'FD':am:'PE'
                  mode = 'LINE'
               case test eq 3 ;* fIle
                  x$cc = 'FI':am:'PE'
                  mode = 'LINE'
               case test eq 4 ;* kill
                  x$cc = 'X'
                  this = orig
                  mode = 'LINE'
               case test eq 5 ;* load
                  crt bott:goup:goup:goup:goup:ceop
                  comd = '' ; rest = ''
                  gosub load.item
                  gosub get.line
                  stub = sysmsg(1750) ;*Press RETURN to continue
                  gosub get.bott
                  gosub disp.page
               case test eq 6 ;* print
                  gosub spool.item
               case test eq 7 ;* quit
                  x$cc = 'Q'
                  mode = 'LINE'
                  if that eq '' and this eq am then this = ''
               case test eq 8 ;* save
                  stub = sysmsg(6306)<29> ;* Enter file and name or just name:
                  gosub get.bott
                  rest = rope
                  if rest ne '' then
                     crt
                     gosub get.bott
                  end
               case test eq 9 ;* write
                  x$cc = 'SAVE':am:'PE'
                  mode = 'LINE'
                  stub = sysmsg(1750) ;*Press RETURN to continue
                  gosub get.bott
            end case
         case test eq 3
            what = convert('~',am,sysmsg(6316)<4>) ;* Edit menu
            choice = what<1> ; gosub f10.menu
            begin case
               case test eq 2 ;* copy
                  if not(beg) or not(fin) then
                     stub = sysmsg(6312)<2> ;*Command requests a block operation, but no block is defined.
                     gosub get.bott
                  end else
                     kept(1) = field(this,am,beg,fin-beg+1)
                  end
               case test eq 3 ;* cut
                  if not(beg) or not(fin) then
                     stub = sysmsg(6312)<2> ;*Command requests a block operation, but no block is defined.
                     gosub get.bott
                  end else
                     kept(1) = field(this,am,beg,fin-beg+1)
                     dawn = beg
                     dusk = fin
                     gosub delete.lines
                  end
               case test eq 4 ;* paste
                  if kept(1) eq '' then
                     stub = sysmsg(6312)<23> ;*Nothing in KEPT buffer
                     gosub get.bott
                  end else
                     gosub get.line
                     line = fmt(line[1,pchr-1],'l#':pchr-1):kept(1):line[pchr,huge]
                     memr(cell)<lnum> = line
                     gosub reset.record
                  end
               case test eq 5 ;* duplicate
                  gosub get.line
                  gosub insert.line
                  gosub reset.record
               case test eq 6 ;* join
                  gosub get.line
                  mine = line
                  here += 1
                  gosub get.line
                  mine := line
                  here -= 1
                  dawn = here
                  dusk = here
                  gosub delete.lines
                  memr(cell)<lnum> = mine
                  gosub reset.record
               case test eq 7 ;* merge
                  if not(beg) or not(fin) then
                     stub = sysmsg(6312)<2> ;*Command requests a block operation, but no block is defined.
                     gosub get.bott
                  end else
                     temp = field(this,am,beg,fin-beg+1)
                     gosub get.line
                     line = fmt(line[1,pchr-1],'l#':pchr-1):temp:line[pchr,huge]
                     memr(cell)<lnum> = line
                     gosub reset.record
                  end
               case test eq 8 ;* move
                  if not(beg) or not(fin) then
                     stub = sysmsg(6312)<2> ;*Command requests a block operation, but no block is defined.
                     gosub get.bott
                  end else
                     if here le fin and here ge beg then
                        stub = sysmsg(6312)<5> ;*A block may not be moved into itself. MERGE will work.
                        gosub get.bott
                     end else
                        rest = beg
                        dusk = fin
                        numb = dusk-rest+1
                        bite = field(this,am,rest,numb)
                        numb = dcount(bite,am)
                        if numb then
                           if here gt dusk then
                              this = insert(this,here+1,0,0,bite)
                              if rest gt 1
                                 then this = this[1,col1()-1]:this[col2(),len(this)]
                                 else this = this[col2()+1,len(this)]
                           end else
                              this = this[1,col1()-1]:this[col2(),len(this)]
                              this = insert(this,here+1,0,0,bite)
                           end
                           gosub set.record
                           if here gt dusk then here = here - numb
                           posn = beg; gosub recalc.posn; beg = posn
                           posn = fin; gosub recalc.posn; fin = posn
                           xxno = dcount(krj<1>,vm)
                           for xx = 1 to xxno
                              posn = krj<2,xx>; gosub recalc.posn; krj<2,xx> = posn
                           next xx
                        end
                     end
                  end
               case test eq 9 ;* line mode
                  mode = 'LINE'
            end case
            pchr = stay
            gosub disp.page
         case test eq 4
            what = convert('~',am,sysmsg(6316)<5>) ;* Search menu
            choice = what<1> ; gosub f10.menu
            begin case
               case test eq 2 ;* reverse search with prompt
                  gosub change.last
                  gosub reverse.search
               case test eq 3 ;* forward search with prompt
                  gosub change.last
                  gosub forward.search
               case test eq 4 ;* reverse search no prompt
                  gosub reverse.search
               case test eq 5 ;* forward search no prompt
                  gosub forward.search
               case test eq 6 ;* change the lastfind string (highlighted string)
                  gosub change.last
               case test eq 7 ;* toggle case flag
                  caseflag = not(caseflag)
            end case
            gosub disp.page
         case test eq 5
            what = convert('~',am,sysmsg(6316)<6>) ;* Logic menu
            choice = what<1> ; gosub f10.menu
            begin case
               case test eq 2  ;* back to label
                  comd = 'FLA' ; rest = ''
                  gosub input.rest
                  gosub find.labels
               case test eq 3  ;* forward to label
                  comd = 'FL'  ; rest = ''
                  gosub input.rest
                  gosub find.labels
               case test eq 4  ;* last label
                  comd = 'FLA' ; rest = '' ; numb = 0
                  gosub find.labels
               case test eq 5  ;* next label
                  comd = 'FL'  ; rest = '' ; numb = 0
                  gosub find.labels
               case test eq 6  ;* last matching
                  comd = 'FMA'
                  gosub find.matches
               case test eq 7  ;* next matching
                  comd = 'FM'
                  gosub find.matches
            end case
            gosub get.line ; mine = line
            ptop = here ; pchr = 1
            gosub disp.page
         case test eq 6      ;* Go to line
            gosub zoot
            gosub disp.page
         case test eq 7
            what = convert('~',am,sysmsg(6316)<7>) ;* Buffer menu
            choice = what<1> ; gosub f10.menu
            begin case
               case test eq 2 ;* oops
                  if oopc ne '' then
                     this = oops
                     here = ooph
                     last = dcount(this,am)
                     beg = oopb
                     fin = oopf
                     krj = oopk
                     gosub set.record
                     stub = sysmsg(6308,oopc,here)<9> ;*"%1" undone - now at line %2.
                     oops = '' ; oopc = '' ; ooph = ''
                     oopb = '' ; oopf = '' ; oopk = ''
                     stay = 1
                  end else
                     stub = sysmsg(6308)<10> ;*last change already "undone" or nothing to undo
                  end
                  gosub get.bott
               case test eq 3 ;* update
                  comi = 'pe|update'
                  gosub savethat
                  that = this
                  CRT 'oopc = ':oopc:; input wait
               case test eq 4 ;* wipe
                  this = orig
                  last = dcount(this,am)
                  comi = 'pe|wipe'
                  here = 1
                  pchr = 1
                  beg = ''; fin = ''; krj = ''
                  save = here
                  that = this ; site = here
                  if this eq '' then this = am
                  ptop = 1
                  gosub savethis
            end case
            pchr = stay
            gosub disp.page
         case test eq 8
            what = convert('~',am,sysmsg(6316)<8>) ;* Code menu
            choice = what<1> ; gosub f10.menu
            temp = ''
            begin case
               case test eq 2 ;* basic
                  temp = 'BASIC'
               case test eq 3 ;* catalog
                  temp = 'CATALOG'
               case test eq 4 ;* run
                  temp = 'RUN'
               case test eq 5 ;* stamp
                  line = sysmsg(6308,name,acct,timedate())<24> ;** Last updated by %1 in account %2 at %3
                  gosub insert.line
                  gosub reset.record
               case test eq 6 ;* format
                  stub = sysmsg(6306)<28> ;* Enter Format Specification
                  gosub get.bott
                  rest = rope
                  gosub clear.page
                  gosub get.format
                  display sysmsg(6310,fr(1),fr(2))<6> ;*Margin=%1, Indentation=%2
                  gosub indenter
                  gosub set.record
                  gosub get.line
                  temp = ''
               case test eq 7 ;* help
            end case
            if temp ne '' then
               gosub exec.that
               stub = sysmsg(1750) ;*Press RETURN to continue
               gosub get.bott
            end
            gosub disp.page
         case test eq 9
            what = convert('~',am,sysmsg(6316)<9>) ;* Tag menu
            choice = what<1> ; gosub f10.menu
            begin case
               case test eq 2 ;* last tag
                  gosub last.tag
               case test eq 3 ;* next tag
                  gosub next.tag
               case test eq 4 ;* set tag
                  gosub set.tag
               case test eq 5 ;* clear this tag
                  locate(here,krj,2;posn) then
                     krj1 = krj<1,posn> ; krj2 = krj<2,posn>
                     stub = sysmsg(6306,krj1,krj2)<26> ;* Tag %1 cleared from line %2
                     del krj<1,posn>
                     del krj<2,posn>
                     if krj<3> ge posn then krj<3> -= 1
                     if krj<3> le 0 then krj<3> = ''
                  end else stub = sysmsg(6306)<25> ;* No Tag found
                  gosub get.bott
               case test eq 6 ;* wipe all tags
                  krj = ''
                  stub = sysmsg(6306)<20> ;*Tags cleared
                  stub := ' - ':sysmsg(1750) ;*Press RETURN to continue
                  gosub get.bott
               case test eq 7 ;* display tags
                  gosub clear.page
                  gosub show.tags
                  stub = sysmsg(1750) ;*Press RETURN to continue
                  gosub get.bott
               case test eq 8 ;* Go to Tag
                  stub = sysmsg(6306)<27> ;* Enter Tag Label
                  gosub get.bott
                  locate(upcase(rope),krj,1;posn) then
                     here = krj<2,posn>
                     krj<3> = posn
                     ptop= here
                     pchr = 1
                  end else
                     stub = sysmsg(6306)<25> ;*No Tag found
                     stub := ' - ':sysmsg(1750) ;*Press RETURN to continue
                     gosub get.bott
                  end
            end case
            gosub disp.page
         case test eq 10     ;* set block start
            beg = here ; gosub disp.page
         case test eq 11     ;* set block end
            fin = here ; gosub disp.page
         case test eq 12     ;* unset block
            beg = 0 ; fin = 0 ; gosub disp.page
         case test eq 13     ;* go to last tag
            gosub last.tag
         case test eq 14     ;* go to next tag
            gosub next.tag
         case test eq 15     ;* set tag on this line
            gosub set.tag
         case test eq 16     ; * toggle colouring'
            brian = not(brian)
            gosub disp.page
         case test eq 17     ;* Half page Move
            pant = int(span/2)
            bolt = int(botl/2)
         case test eq 18     ;* Full page Move
            pant = span
            bolt = botl
         case test eq 19 and mouser
            if scat
               then crt mouse.off
               else crt mouse.on
            scat = not(scat)
      end case
      gosub disp.page
      what = ''
      return

last.tag:
      posn = krj<3>-1
      if posn le 0 then posn = dcount(krj<2>,vm)
      if posn gt 0 then
         here = krj<2,posn>
         krj<3> = posn
         ptop = here
         pchr = 1
         gosub disp.page
         gosub get.line; mine = line
      end else
         stub = sysmsg(6306)<25> ;*No Tag found
         stub := ' - ':sysmsg(1750) ;*Press RETURN to continue
         gosub get.bott
      end
      return

next.tag:
      posn = krj<3>+1
      if posn gt dcount(krj<2>,vm) then posn = 1
      if posn ne '' and posn le dcount(krj<2>,vm) then
         here = krj<2,posn>
         krj<3> = posn
         ptop = here
         pchr = 1
         gosub disp.page
         gosub get.line; mine = line
      end else
         stub = sysmsg(6306)<25> ;*No Tag found
         stub := ' - ':sysmsg(1750) ;*Press RETURN to continue
         gosub get.bott
      end
      return

set.tag:
      locate(here,krj,2;posn) then
         stub = sysmsg(6306,here)<23> ;*There is already a Tag on line %1
         stub := ' - ':sysmsg(1750) ;*Press RETURN to continue
         gosub get.bott
         display bott:revb:sysmsg(6308)<27>:revf: ;*Press <F1> for help.
         return
      end
      rest = 'T':here
      rest = trim(upcase(rest))
      locate(rest,krj,1;posn) then
         stub = sysmsg(6306,rest)<24> ;*There is already a Tag lablled %1
         stub := ' - ':sysmsg(1750) ;*Press RETURN to continue
         gosub get.bott
         display bott:revb:sysmsg(6308)<27>:revf: ;*Press <F1> for help.
         return
      end
      posn = krj<3>
      krj<1> = field(krj<1>,vm,1,posn)
      posn += 1
      krj<1,posn> = rest
      krj<2,posn> = here
      krj<3> = posn
      return

f10.menu:
      spar = ''
      pool = char(27)
      lenc = len(choice)
      for ll = 1 to lenc
         bit = choice[ll,1]
         if bit ne downcase(bit) or index('<>/[]\|{}^',bit,1)   then
            pool := bit
            spar := hi.selecton:bit:hi.selectoff
         end else spar := bit
      next ll
      zone = ' ':revb:str('?',span-lenc-1):revf

      crt @(0,0):ceol:spar:zone:
      crt @(pcol,prow):
      loop
         gosub get.keyc
         keyc = upcase(keyc)
         test = index(pool,keyc,1)
      until test do
         if cpos eq mous then
            if mrow eq '' then continue
            if mrow lt 1  then
               keyc = choice[mcol+1,1]
               test = index(pool,keyc,1)
               if test gt 1 then return
               if mcol gt lenc and mcol lt (span-1) then keyc = '?'
            end else
               test = 1
               return
            end
         end
         if cpos eq phlp or keyc eq '?' then
            disp = what
            disp<1> = spar
            crt clpg
            temp = pcol:am:pchr:am:ppos
            gosub show.disp
            stub = sysmsg(1750) ;*Press RETURN to continue
            gosub get.bott
            pcol = temp<1> ; pchr = temp<2> ; ppos = temp<3>
            gosub disp.page
            crt @(0,0):ceol:spar:zone:
            crt @(pcol,prow):
         end
      repeat
      return

*----------- colouring thanks to Brian Leach
colour.line:

      yyno = len(linr)
      if biggest and yyno gt biggest then
         lins = linr[offset,width]
         return
      end
      lino = linr
      linr = trimf(linr)
      mask = space(yyno - len(linr))
      gosub get.label
      if labl ne '' then
         mask := str(si.label,len(labl)):' '
         linr = linr[len(labl)+1,huge]
      end
      word = linr[' ',1,1]

      begin case
         case word[1,1] match '*':vm:'!'
            if count(linr,'@@')
               then mask := str(si.doc, yyno)
               else mask := str(si.comment, yyno)
         case word[1,1] eq '$' or word[1,1] eq '#'
            mask := str(si.directive, yyno)
         case 1
            zzno = count(linr,';')
            if not(zzno) then
               mask := space(yyno)
            end else
               foundcomment = @false
               for zz = 1 to zzno until foundcomment
                  word = trimf(linr[';',zz+1,1])
                  if word[1,1] eq '*' or word[1,1] eq '!' then
                     word = linr[';',1,zz]
                     aano = len(word)
                     flag = ''
                     for aa = 1 to aano
                        bit = word[aa,1]
                        if bit eq flag then
                           flag = ''
                        end else
                           if index(qt,bit,1) then flag = bit
                        end
                     next aa
                     if flag eq '' then foundcomment = zz
                  end
               next zz
               if foundcomment
                  then mask := space(len(linr[';',1, foundcomment])):str(si.comment, yyno)
                  else mask := space(yyno)
            end
      end case
      linv = convert(pchars, pchart, upcase(lino))
      zzno = dcount(linv,@fm)
      for zz = 1 to zzno
         word = linv[@fm,zz,1]
         if word eq '' then continue            ;* A useful thing - why???
         bcol = col1()+ 1
         if bcol gt 1 then
            if mask[bcol-1,1] eq ' ' and lino[bcol-1,1] ne ' ' then
               mask[bcol-1,1] = si.operator           ; * operators too
            end
         end
         if index(qt,word[1,1],1) then
            posb = index(linv[bcol+1,huge],word[1,1],1)
            if posb and mask[bcol,1] eq ' ' then
               zz = dcount(linv[1, posb+bcol],@fm)
               mask[bcol, posb+1] = str(si.string, posb+1)
            end
         end else
            locate(word,fwords;posn;'AL') then
* Functions are followed by a bracket
               brak = ''
               fpos = len(linv[@fm,1,zz])+1
               if fpos then brak = trim(lino[fpos,huge])[1,1]
               if brak eq '(' and mask[bcol,1] eq ' ' then
                  mask[bcol,len(word)] = str(si.function, len(word))
               end
            end
            locate(word,kwords;posn;'AL') then
               if mask[bcol,1] eq ' ' then
                  mask[bcol, len(word)] = str(si.key, len(word))
               end
            end
         end
      next zz

      word = lastfind
      if word ne '' then
         vary = 1
         loop
            if caseflag
               then posb = index(lino,word,vary)
               else posb = index(upcase(lino),upcase(word),vary)
         while posb do
            vary += 1
            mask[posb, len(word)] = str(si.highlight, len(word))
         repeat
      end

      linr = lino[offset,width]
      mask = mask[offset,width]
      lins = ''
      oldm = ''
      yyno = len(linr)
      for yy = 1 to yyno
         newm = mask[yy,1]
         if newm ne oldm then
            begin case
               case oldm eq si.label
                  lins := hi.labeloff
               case oldm eq si.comment
                  lins := hi.commentoff
               case oldm eq si.key
                  lins := hi.keyoff
               case oldm eq si.string
                  lins := hi.stringoff
               case oldm eq si.key
                  lins := hi.keyoff
               case oldm eq si.operator
                  lins := hi.opoff
               case oldm eq si.function
                  lins := hi.funcoff
               case oldm eq si.directive
                  lins := hi.diroff
               case oldm eq si.highlight
                  lins := hi.selectoff
            end case
            begin case
               case newm eq si.label
                  lins := hi.labelon
               case newm eq si.comment
                  lins := hi.commenton
               case newm eq si.key
                  lins := hi.keyon
               case newm eq si.string
                  lins := hi.stringon
               case newm eq si.operator
                  lins := hi.opon
               case newm eq si.function
                  lins := hi.funcon
               case newm eq si.directive
                  lins := hi.diron
               case newm eq si.highlight
                  lins := hi.selecton
               case newm eq si.doc
                  lins := hi.docon
            end case
            oldm = mask[yy,1]
         end
         lins := linr[yy,1]
      next yy
      begin case
         case oldm eq si.label
            lins := hi.labeloff
         case oldm eq si.comment
            lins := hi.commentoff
         case oldm eq si.key
            lins := hi.keyoff
         case oldm eq si.string
            lins := hi.stringoff
         case oldm eq si.function
            lins := hi.funcoff
         case oldm eq si.operator
            lins := hi.opoff
         case oldm eq si.directive
            lins := hi.diroff
         case oldm eq si.highlight
            lins := hi.selectoff
         case oldm eq si.doc
            lins := hi.docoff
      end case
      return

outline:
* to display logic simplisticly
      save = here
      bot = here
      if bot lt 1 or bot gt last then bot = 1
      if numb then msup = here + numb else msup = last
      if msup gt last then msup = last
      rest = trim(upcase(rest))
      if index(rest,'*',1) then rest = 'CEPST'
      disp     = 'LOGIC for ':dprt:' ':fprt:' ':item:' ':bot:'-':msup
      disp<-1> = '      labels, GOTOs, GOSUBs'
      if index(rest,'C',1) then disp := ', CALLs'
      if index(rest,'E',1) then disp := ', EXECUTEs'
      if index(rest,'P',1) then disp := ', PERFORMs'
      if index(rest,'S',1) then disp := ', CASEs'
      if index(rest,'T',1) then disp := ', TAGs'
      disp<-1> = str('=',len(disp<2>))

      for here = bot to msup
         gosub get.line
         linr = line
         gosub get.label
         bite = upcase(line)
         bite = ' ':upcase(line)
         if chit eq '*' or chit eq '!'
            then chit = @false
            else chit = @true
         begin case
            case chit and index(bite,' GOTO ',1)
            case chit and index(bite,' GO ',1)
            case chit and index(bite,' GOSUB ',1)
            case rest eq '' ; bite = ''
            case chit and index(rest,'C',1) and index(bite,' ':'CALL',1)
            case chit and index(rest,'E',1) and index(bite,' ':'EXECUTE',1)
            case chit and index(rest,'P',1) and index(bite,' ':'PERFORM',1)
            case chit and index(rest,'S',1) and index(bite,' ':'CASE',1)
            case index(rest,'T',1)
               locate(here,krj,2;posn) else bite = ''
            case 1 ; bite = ''
         end case
         if labl ne '' or bite ne '' then
            convert badc to gudc in line
            disp<-1> = fmt(here,lfmt):': ':line
         end
      next here
      stub = ''
      if hard then gosub print.disp else gosub show.disp
      here = save
      return

hardcase:
      bite = mope[pchr,1]
      if bite ne '' and (alpha(bite) or num(bite) or index(inword,bite,1)) then
         test = pchr
         loop
            test -= 1
            bite  = mope[test,1]
         while test
         until not(alpha(bite) or num(bite) or index(inword,bite,1)) do repeat
         left = test + 1
         test = pchr
         loop
            test += 1
            bite = mope[test,1]
         until bite eq ''
         while (alpha(bite) or num(bite) or index(inword,bite,1)) do repeat
      end else
         left = 1 ; test = len(mope)+1
      end
      cope = mope[left,test-left]
      gosub rope.a.dope
*     mope = mope[1,left-1]:cope:mope[test,huge]
      mope[left,test-left] = cope
      return

rope.a.dope:
      dope = downcase(cope)
      hope = upcase(cope)
      tope = oconv(cope,'MCT')
      begin case
         case cope eq tope ; cope = dope
         case cope eq hope ; cope = tope
         case 1 ; cope = hope
      end case
      return

get.mouse:
      mrow = ''
      mcol = ''
      begin case
         case mouser eq 'ASCII'
            loop while keyready()
               keyc = keyin()
            until mcol ne '' and keyc eq char(13) do
               if keyc ne char(13) then mcol := keyc
            repeat
            mrow = matchfield(mcol,'0N.0N',3)
            mcol = matchfield(mcol,'0N.0N',1)
         case mouser eq 'ANSI'
            loop while keyready()
               keyc = keyin()
            until keyc eq 'R' do
               mcol := keyc
            repeat
            mrow = matchfield(mcol,'2X0N;0N',2)-1
            mcol = matchfield(mcol,'2X0N;0N',4)-1
            if mrow lt 0 or mcol lt 0 then mrow = ''
         case mouser eq 'HOSTACCESS'
            loop while keyready()
               keyc = keyin()
            until keyc eq char(13) do
               mcol := keyc
            repeat
            mrow = matchfield(mcol,'0N,0N,0N',3)-1
            mcol = matchfield(mcol,'0N,0N,0N',5)-1
            if mrow lt 0 or mcol lt 0 then mrow = ''
         case mouser eq 'XTERM'
            loop while keyready()
               keyc = keyin()
               mcol := keyc
            until len(mcol) eq 3 do
            repeat
* 32=left 33 =centre 34=right 35=release 96=wheelup 97=wheeldown
            bite = seq(mcol[1,1])
!           if len(mcol) eq 3 and bite eq 32 then ;* only on left click
            if len(mcol) eq 3 and bite eq 35 then ;* release on any button
               mrow = seq(mcol[3,1])-33
               if mrow lt 0 then mrow += 128
               mcol = seq(mcol[2,1])-33
               if mcol lt 0 then mcol += 128
            end
$ifdef qmterm
         case mouser eq 'QMTERM' and @MBUTTON eq 1
            mrow = @MROW
            mcol = @MCOL
$endif
      end case
      if mrow eq '' then mcol = ''
      return

get.buffer:
      bnum = numb
      if bnum eq '' and rest matches '1N0N' then bnum = rest
      bnum = bnum[1,1]
      return

$ifdef qm
external.command:
      crt
      prog.no = ext.posn<inmat()>
      prog = ext.prog<prog.no>
      if not(catalogued(prog)) then
         display sysmsg(6992,prog)
         return
      end
      mat ext.data = ''
      fnam% = fnam
      item% = item
      this% = this
      here% = here
      beg% = beg
      fin% = fin
      ucom% = upcase(comi)

      ext.fail = @false
      ext.changed = @false
      call @prog(mat ext.data,ext.fail)
      if not(ext.fail) then
         if this% ne this
            then ext.changed = @true
         if here% ne here and here% matches '1N0N'
            then ext.changed = @true
            else here% = here
         if beg% ne beg and beg% matches '1N0N'
            then ext.changed = @true
            else beg% = beg
         if fin% ne fin and fin% matches '1N0N'
            then ext.changed = @true
            else fin% = fin
         if ext.changed then
            gosub savethat
            this = this%
            here = here%
            beg = beg%
            fin = fin%
            if last ne dcount(this,am) then krj = ''
            last = dcount(this,am)
            if beg gt last then beg = last
            if fin gt last then fin = last
            if fin lt beg then fin = beg
            gosub set.record
            gosub display.line
         end
      end
      mat ext.data = ''
      return
$endif
ae.help:
      crt
      disp = sysmsg(6317,verb)
      gosub show.disp
      stop
